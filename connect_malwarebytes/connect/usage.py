import os
import time
import uuid

from connect.client import ClientError

from typing import Dict, List, Optional, Tuple
from datetime import date, datetime

from malwarebytes.account.infrastructure.http import APIClient, MBAccountRepository
from malwarebytes.account.application.services import BillingGetter

from connect_malwarebytes.connect import const
from connect_malwarebytes.connect.excel import ExcelFileGenerator, UsageLine
from connect_malwarebytes.connect.request import get_param_value


class ConnectUsageError(Exception):
    pass  # pragma: no cover


def format_connect_date(date_time: datetime) -> str:
    if hasattr(date_time, 'microsecond'):
        date_time = date_time.replace(microsecond=0)
    return date_time.strftime(f'{const.SIMPLE_DATE_FORMAT} {const.TIME_FORMAT}')


class ListingGetter:
    def __init__(self, client, logger):
        self.client = client
        self.logger = logger

    def execute(self, product_id: str):
        """
        Gets the list of Listings for the given product

        Parameters
        ----------
        product_id : str
            The product id

        Returns
        -------
        List[Dict]
            The list of Listings
        """
        return self.client.listings.filter(product__id=product_id).filter(status=const.LISTED)


class AssetsGetter:
    def __init__(self, client, logger):
        self.client = client
        self.logger = logger

    def execute(self, product_id: str, contract_id: str):
        """
        Gets the list of Assets for the given product and contract

        Parameters
        ----------
        product_id : str
            The product id

        contract_id : str
            The contract id

        Returns
        -------
        List[Dict]
            The list of Assets
        """
        return self.client.assets.filter(product__id=product_id).filter(
            contract__id=contract_id).filter(status__in=(const.ACTIVE, const.SUSPENDED))


class AssetReport:
    def __init__(self, asset: Dict, logger, config):
        self.asset = asset
        self.logger = logger
        self.config = config

    def config_params(self):
        return self.asset['configuration']['params']

    def environment(self):
        return self.asset['connection']['type']

    def items(self):
        return self.asset['items']

    def params(self):
        return self.asset['params']

    def msp_account_id(self):
        return get_param_value(self.params(), const.MSP_ACCOUNT_ID_FULFILLMENT)

    def api_url(self) -> str:
        """
        Get Api URl.
        :return: str
        """
        keys = {
            const.TEST_ENV: const.MB_API_URL_TEST,
            const.PREVIEW_ENV: const.MB_API_URL_PREVIEW,
            const.PRODUCTION_ENV: const.MB_API_URL}

        return get_param_value(self.config_params(), keys[self.environment()])

    def api_secret(self) -> str:
        """
        Get Api Secret.
        :return: str
        """
        keys = {
            const.TEST_ENV: const.MB_OAUTH_CLIENT_SECRET_TEST,
            const.PREVIEW_ENV: const.MB_OAUTH_CLIENT_SECRET_PREVIEW,
            const.PRODUCTION_ENV: const.MB_OAUTH_CLIENT_SECRET}

        return get_param_value(self.config_params(), keys[self.environment()])

    def api_client_id(self) -> str:
        """
        Get Client Id.
        :return: str
        """
        keys = {
            const.TEST_ENV: const.MB_OAUTH_CLIENT_ID_TEST,
            const.PREVIEW_ENV: const.MB_OAUTH_CLIENT_ID_PREVIEW,
            const.PRODUCTION_ENV: const.MB_OAUTH_CLIENT_ID}

        return get_param_value(self.config_params(), keys[self.environment()])

    def api_client(self) -> APIClient:

        return APIClient(
            mb_oauth_url=self.api_url(),
            mb_oauth_client_id=self.api_client_id(),
            mb_oauth_client_secret=self.api_secret(),
            mb_api_url=self.api_url(),
            logger=self.logger)

    def account_repository(self):
        return MBAccountRepository(self.api_client(), self.logger)

    def execute(self, start_date: date, end_date: date) -> List[UsageLine]:
        """
        Gets the usage lines for the given asset

        Parameters
        ----------
        start_date : date
            The start date of the usage report

        end_date : date
            The end date of the usage report

        Returns
        -------
        List[UsageLine]
            The list of UsageLines that includes the billing data
        """
        usage_lines = []

        self.logger.info(f'Getting usage for Account {self.msp_account_id()}')
        billing_data = BillingGetter(
            repository=self.account_repository(), logger=self.logger).execute(
            self.msp_account_id(), start_date, end_date)

        if not billing_data:
            self.logger.warning(f'No billing data found for Account {self.msp_account_id()}')
            return []

        for product_id, line in billing_data.items():
            usage_line = UsageLine()
            usage_line.id = str(uuid.uuid4())
            usage_line.record_note = ''
            usage_line.item_search_criteria = const.ITEM_MPN_SEARCH_CRITERIA
            usage_line.item_search_value = product_id
            usage_line.asset_search_criteria = 'parameter.' + const.MSP_ACCOUNT_ID_FULFILLMENT
            usage_line.asset_search_value = self.msp_account_id()
            usage_line.start_time = format_connect_date(start_date)
            usage_line.end_time = format_connect_date(end_date)
            usage_line.quantity = float(line.get('usage'))
            usage_line.item_name = line.get('catalog_code')
            usage_line.item_id = line.get('product_code')
            usage_line.item_mpn = line.get('billable_catalog_code')
            usage_line.item_unit = const.USAGE_UNIT

            usage_lines.append(usage_line)

        self.logger.info(
            f'Found {len(usage_lines)} usage lines for MSP Account ID: {self.msp_account_id()}')
        return usage_lines


class UsageFileGenerator:
    def __init__(self, config, logger):
        self.logger = logger
        self.config = config

    def execute(self, assets: list, contract_id: str, start_date: date,
                end_date: date) -> Optional[str]:
        """
        Generates the usage file for the given assets

        Parameters
        ----------
        assets : list
            The list of assets to generate the usage file for

        contract_id : str
            The contract id of the usage file

        start_date : date
            The start date of the usage report

        end_date : date
            The end date of the usage report

        Returns
        -------
            The usage file name
        """

        usage_lines, environment = self._get_usage_lines(assets, start_date, end_date)

        if not usage_lines:
            self.logger.warning(f'No usage lines found for contract {contract_id}')
            return None

        usage_filename = self._get_filename(contract_id, environment)
        self.logger.info(
            f'Generating usage file (local) {usage_filename} for contract {contract_id}')
        ExcelFileGenerator(self.logger).create_file(usage_filename).add_lines(
            usage_lines)

        return usage_filename

    def _get_filename(self, contract_id: str, environment: str) -> str:
        """
        Returns the filename for the usage file

        Parameters
        ----------
        contract_id: str
            The contract id

        environment: str
            The environment

        Returns
        -------
        str
            The filename
        """

        current_date = datetime.now().strftime(f'{const.FILE_DATE_FORMAT}_{const.FILE_TIME_FORMAT}')
        return (f'{const.CONNECT_USAGE_FILE}_{contract_id}_{environment}_{current_date}'
                f'{const.USAGE_FILE_FORMAT}')

    def _get_usage_lines(self, assets: list, start_date: date, end_date: date,
                         ) -> Tuple[List[UsageLine], str]:
        """
        Returns the usage lines for the given assets

        Parameters
        ----------
        assets: list
            The list of assets

        start_date: date
            The start date for the usage lines

        end_date: date
            The end date for the usage lines

        Returns
        -------
        Tuple[List[UsageLine], str]
            The list of UsageLines and the environment
        """
        usage_lines = []
        environment = ""

        for asset_data in assets:
            asset = AssetReport(asset_data, self.logger, self.config)

            usage_lines.extend(asset.execute(start_date, end_date))
            environment = asset.environment()

        return usage_lines, environment


class ReportUploader:
    def __init__(self, client, logger) -> None:
        self.client = client
        self.logger = logger

    def execute(self, product_id: str, filename: str, contract_id: str, start_date: date,
                end_date: date):
        """
        Uploads the usage file to the Connect platform

        Parameters
        ----------
        product_id: str
            The product id

        filename: str
            The filename of the usage file

        contract_id: str
            The contract id

        start_date: date
            The start date of the usage report

        end_date: date
            The end date of the usage report
        """

        try:
            self.logger.info(f'Creating Usage File for contract {contract_id} in Connect')
            usage_file_response = self._create_usage_report(product_id, filename, contract_id,
                                                            start_date, end_date)
            self.logger.info(f'Uploading Excel file for contract {contract_id} to Connect')
            self._upload_usage_report(usage_file_response['id'], filename)
            self.logger.info(f'Submitting Usage File for contract {contract_id}')
            self._submit_usage_report(usage_file_response['id'])
            os.remove(filename)
            self.logger.info(
                f'Successfully Submitted the Usage File for contract {contract_id}. Local file '
                f'removed')
        except (ClientError, FileNotFoundError) as e:
            self.logger.error(
                f'Failed to upload usage report for Product:{product_id}, Contract: {contract_id}. '
                f'Error: {e}')
            raise ConnectUsageError()

    def _create_usage_report(self, product_id: str, name: str, contract_id: str,
                             start_date: date, end_date: date) -> Dict:
        """
        Creates the usage report in Connect

        Parameters
        ----------
        product_id: str
            The product id

        name: str
            The name of the usage report

        contract_id: str
            The contract id

        start_date: date
            The start date of the usage report

        end_date: date
            The end date of the usage report

        Returns
        -------
        dict
            The response from the usage report creation
        """

        usage_file_data = {
            "name": name,
            "description": name,
            "note": "",
            "period": {
                "from": format_connect_date(start_date),
                "to": format_connect_date(end_date),
            },
            "product": {
                "id": product_id,
            },
            "contract": {
                "id": contract_id,
            },
        }

        return self.client.create('usage/files', payload=usage_file_data)

    def _upload_usage_report(self, usage_file_id: str, filename: str):
        """
        Uploads the usage report file to Connect

        Parameters
        ----------
        usage_file_id: str
            The usage file id in Connect

        filename: str
            The filename of the usage report
        """
        self.client.create(f'usage/files/{usage_file_id}/upload',
                           files={'usage_file': open(filename, 'rb')})

    def _submit_usage_report(self, usage_file_id: str):
        """
        Submits the usage report to Connect

        Parameters
        ----------
        usage_file_id: str
            The usage file id in Connect
        """
        status = None

        self.logger.info(f'Waiting for Ready status for Usage File {usage_file_id}')
        while status != const.STATUS_READY:
            time.sleep(30)
            status = self.client.get(f'usage/files/{usage_file_id}')['status']

        self.client.create(f'usage/files/{usage_file_id}/submit')


class ReportInfo:
    def __init__(self, client, logger):
        self.client = client
        self.logger = logger

    def get_last(self, contract_id: str, product_id: str) -> Dict:
        return self.client.ns('usage').files.filter(
            contract_id=contract_id).filter(product_id=product_id).order_by("-created.at").first()
