from dataclasses import dataclass
from typing import Dict, List, Optional

from connect_malwarebytes.connect import const


class ConfigurationError(Exception):
    def __init__(self, message: str, parameter: str):
        self.message = message
        self.parameter = parameter

        super().__init__(self.message)


class RatingPlanError(Exception):
    pass  # pragma: no cover


# Search param by Id.
def search_param(params: List, id: str) -> Optional[Dict]:
    """Returns the parameter dict by its id"""
    try:
        return next(filter(lambda param: param['id'] == id, params))
    except StopIteration:
        return None


# Get param by Id.
def get_param_value(params: List, id: str) -> str:
    """Returns the parameter value by its id"""
    if not params:
        return ''
    param = search_param(params, id)
    return param.get('value') if param else ''


@dataclass
class RequestParser:
    """Request base"""
    request: Dict
    config: Dict

    @staticmethod
    def get_instance(request, config):
        """Dynamically resolves the request type"""
        if 'id' not in request:
            return None

        result = None
        if request['id'].startswith(const.ASSET_REQUEST_PREFIX):
            result = AssetRequest(request, config)
        elif request['id'].startswith(const.ASSET_DATA_PREFIX):
            result = AssetData(request, config)
        return result

    def id(self) -> str:
        return self.request['id']

    def status(self):
        return self.request['status']

    def set_status(self, status):
        self.request['status'] = status

    def params(self) -> List[Dict]:
        return self.request['params']

    def config_params(self) -> List[Dict]:
        return self.request['configuration']['params']

    def product_id(self) -> str:
        return self.request['product']['id']

    def environment(self) -> str:
        return self.request['connection']['type']

    def update_parameter(self, param_id: str, value: str = '', value_error: str = None) -> None:
        parameter = search_param(self.params(), param_id)
        if value:
            parameter['value'] = value
        if value_error is not None:
            parameter['value_error'] = value_error


class AssetRequest(RequestParser):
    """Parser for fulfillment/asset requests (PR prefix)"""

    def __init__(self, request, config):
        super().__init__(request, config)
        self.asset = AssetData(self.request['asset'], config)

    def params(self) -> List[Dict]:
        return self.asset.params()

    def items(self) -> List[Dict]:
        return self.asset.items()

    def tiers(self) -> List[Dict]:
        return self.asset.tiers()

    def asset_company_name(self) -> str:
        return self.asset.company_name()

    def asset_billing_street(self) -> str:
        return self.asset.billing_street()

    def asset_billing_city(self) -> str:
        return self.asset.billing_city()

    def asset_billing_country(self) -> str:
        return self.asset.billing_country()

    def asset_billing_state(self) -> str:
        return self.asset.billing_state()

    def config_params(self) -> List[Dict]:
        return self.asset.config_params()

    def product_id(self) -> str:
        return self.asset.product_id()

    def environment(self) -> str:
        return self.asset.environment()

    def asset_id(self) -> str:
        return self.asset.id()

    def generate_params_for_update(self) -> Dict:
        return {'asset': {'params': self.params()}}

    def migration_info(self) -> Optional[str]:
        try:
            return get_param_value(self.params(), const.MIGRATION_INFO_PARAM)
        except ConfigurationError:
            return None

    def api_url(self) -> str:
        keys = {
            const.TEST_ENV: const.MB_API_URL_TEST,
            const.PREVIEW_ENV: const.MB_API_URL_PREVIEW,
            const.PRODUCTION_ENV: const.MB_API_URL}

        return get_param_value(self.config_params(), keys[self.environment()])

    def api_secret(self) -> str:
        keys = {
            const.TEST_ENV: const.MB_OAUTH_CLIENT_SECRET_TEST,
            const.PREVIEW_ENV: const.MB_OAUTH_CLIENT_SECRET_PREVIEW,
            const.PRODUCTION_ENV: const.MB_OAUTH_CLIENT_SECRET}

        return get_param_value(self.config_params(), keys[self.environment()])

    def api_client_id(self) -> str:
        keys = {
            const.TEST_ENV: const.MB_OAUTH_CLIENT_ID_TEST,
            const.PREVIEW_ENV: const.MB_OAUTH_CLIENT_ID_PREVIEW,
            const.PRODUCTION_ENV: const.MB_OAUTH_CLIENT_ID}

        return get_param_value(self.config_params(), keys[self.environment()])

    def subscription_activation_template_id(self) -> str:
        return get_param_value(self.config_params(), const.SUBSCRIPTION_ACTIVATION_TEMPLATE_ID_KEY)


class AssetData(RequestParser):
    """Parser for asset data (AS prefix)"""

    def items(self) -> List[Dict]:
        return self.request['items']

    def tiers(self) -> List[Dict]:
        return self.request['tiers']

    def company_name(self) -> str:
        return self.request['tiers']['customer']['name']

    def billing_street(self) -> str:
        return self.request['tiers']['customer']['contact_info']['address_line1']

    def billing_city(self) -> str:
        return self.request['tiers']['customer']['contact_info']['city']

    def billing_country(self) -> str:
        return self.request['tiers']['customer']['contact_info']['country']

    def billing_state(self) -> str:
        return self.request['tiers']['customer']['contact_info']['state']
