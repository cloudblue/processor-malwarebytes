from typing import List, Optional

from connect.eaas.extension import ValidationResponse

from connect_malwarebytes.connect.request import ConfigurationError, OrderingError, get_param_value
from connect_malwarebytes.connect.messages import RATING_PLAN_PARAMETER_NOT_FOUND, \
    RATING_PLAN_PARAMETER_NOT_VALID
from connect_malwarebytes.flows.flows import Flow, ProcessingFlow
from connect_malwarebytes.flows.purchase_flow import PurchaseFlow
from connect_malwarebytes.connect.const import (
    CONTACT_FIRST_NAME,
    CONTACT_LAST_NAME,
    CONTACT_EMAIL_NAME,
    CONTACT_PHONE_NAME,
    MSP_ACCOUNT_ID,
    STATUS_DRAFT,
    ONEVIEW_MONTHLY_MPN,
    ONEVIEW_MONTHLY_IMPORT_MPN,
    ONEVIEW_TRIAL_MPN,
    ACCOUNT_COMPANY_NAME,
    BILLING_CITY,
    BILLING_STREET,
    BILLING_COUNTRY,
    BILLING_STATE,
    RESERVATION_ITEM,
)

from malwarebytes.account.application.services import AccountGetter
from malwarebytes.account.domain.messages import (
    FIRST_NAME_INVALID_FORMAT_MESSAGE,
    LAST_NAME_INVALID_FORMAT_MESSAGE,
    PHONE_INVALID_FORMAT_MESSAGE,
    EMAIL_INVALID_FORMAT_MESSAGE,
    MSP_ID_INVALID_FORMAT_MESSAGE,
    EXISTING_EMAIL,
    COMPANY_NAME_INVALID,
    STREET_NAME_INVALID,
    CITY_NAME_INVALID,
    COUNTRY_NAME_INVALID,
    STATE_NAME_INVALID,
    EXISTING_MSP_ACCOUNT_ID,

)
from malwarebytes.account.domain.exceptions import (
    InvalidFirstNameFormatError,
    InvalidLastNameFormatError,
    InvalidEmailFormatError,
    InvalidPhoneFormatError,
    InvalidCompanyNameFormatError,
    InvalidStreetNameFormatError,
    InvalidCityNameFormatError,
    InvalidCountryNameFormatError,
    InvalidStateNameFormatError,
)
from malwarebytes.account.domain.models import (
    FirstName,
    LastName,
    Email,
    Phone,
    MSPAccount,
    Account,
    AccountId,
)

global type_plan, first_name, last_name, phone, email


class ValidationFlow(Flow):
    """A subclass for validation flows"""

    def handle(self) -> ValidationResponse:
        try:
            return super().handle()
        except ConfigurationError:
            if self.request_data.status() == STATUS_DRAFT:
                return ValidationResponse.done(self.request_data.request)
            return ValidationResponse.fail()


class PurchaseDraftValidation(ValidationFlow):
    """
    Validate:
    - the parameters required to create (or import) a subscription.
    - Check if email exists or not in MalwareBytes.
    - Validate type of subscription.
    """

    def process(self) -> ValidationResponse:
        """
        Entry point for DraftValidation Flow.
        :return: ValidationResponse
        """
        self.logger.info(
            f"Starting Validation process for request {self.request_data.id()} with status "
            f"{self.request_data.status()}.")

        self.clear_errors()

        error_params = self._validate_create_subscription()

        for param in error_params:
            self.request_data.update_parameter(
                param_id=param['id'],
                value_error=param['value_error'],
            )

        return ValidationResponse.done(self.request_data.request)

    def clear_errors(self):
        """Clears the value_error field of the parameters used in the flow"""
        self.request_data.update_parameter(param_id=CONTACT_FIRST_NAME, value_error='')
        self.request_data.update_parameter(param_id=CONTACT_LAST_NAME, value_error='')
        self.request_data.update_parameter(param_id=CONTACT_EMAIL_NAME, value_error='')
        self.request_data.update_parameter(param_id=CONTACT_PHONE_NAME, value_error='')
        self.request_data.update_parameter(param_id=ACCOUNT_COMPANY_NAME, value_error='')
        self.request_data.update_parameter(param_id=BILLING_STREET, value_error='')
        self.request_data.update_parameter(param_id=BILLING_CITY, value_error='')
        self.request_data.update_parameter(param_id=BILLING_COUNTRY, value_error='')

    def _validate_create_subscription(self) -> List[dict]:
        """
        Validate the parameters required to create (or import) a subscription.
        :return: List[dict]
        """
        if self.request_data.status() == STATUS_DRAFT:
            try:
                # Validate that all params are right and not empty.
                self.type_plan = ProcessingFlow.validate_items(self)
            except OrderingError as ex:
                self.logger.error(f"There was the following error: {ex}")
                raise

        params = self.request_data.params()

        error_params = []
        try:
            self.first_name = get_param_value(params, CONTACT_FIRST_NAME)
            FirstName(self.first_name)
            self.last_name = get_param_value(params, CONTACT_LAST_NAME)
            LastName(self.last_name)
            self.phone = get_param_value(params, CONTACT_PHONE_NAME)
            Phone(self.phone)
            self.email = get_param_value(params, CONTACT_EMAIL_NAME)
            Email(self.email)
        except InvalidFirstNameFormatError as ex:
            error_params.append({
                "id": CONTACT_FIRST_NAME,
                "value_error": FIRST_NAME_INVALID_FORMAT_MESSAGE.format(self.first_name)})
        except InvalidLastNameFormatError as ex:
            error_params.append({
                "id": CONTACT_LAST_NAME,
                "value_error": LAST_NAME_INVALID_FORMAT_MESSAGE.format(self.last_name)})
        except InvalidPhoneFormatError as ex:
            error_params.append({
                "id": CONTACT_PHONE_NAME,
                "value_error": PHONE_INVALID_FORMAT_MESSAGE.format(self.phone)})
        except InvalidEmailFormatError as ex:
            error_params.append({
                "id": CONTACT_EMAIL_NAME,
                "value_error": EMAIL_INVALID_FORMAT_MESSAGE.format(self.email)})
        else:
            error_params = self._validate_per_type_subscription(error_params)

        return error_params

    def validate_items(self) -> Optional[str]:
        """
        Checks if product items are correctly configured
        For 'Rating Plan - Reservation' only one must be added.
        :return: Optional[str]
        """
        self.logger.info('Checking item values.')

        if not self.request_data.rating_plan_item():
            self.logger.error(f'There is no Rating Plan item in request {self.request_data.id()}.')
            raise OrderingError(RATING_PLAN_PARAMETER_NOT_FOUND)

        cont = 0
        reservation_item = ""
        all_items = self.request_data.rating_plan_items()
        for item in all_items:
            if item.get('item_type') == RESERVATION_ITEM:
                cont += 1
                reservation_item = item

        # Check if there is only one reservation item.
        if cont <= 1 and reservation_item != "":
            return reservation_item.get('mpn')

        # If there are more than one Item type Reservation show an error.
        if cont > 1:
            self.logger.error(f'There are more than one Rating Plan item in request '
                              f'{self.request_data.id()}.')

        raise OrderingError(RATING_PLAN_PARAMETER_NOT_VALID)

    def _validate_per_type_subscription(self, error_params) -> dict:
        """
        Validate type of subscription.
        :param error_params:
        :return: dict
        """
        if self._check_existing_email():
            self.logger.error("Email already exists in MalwareBytes.")
            error_params.append({
                "id": CONTACT_EMAIL_NAME,
                "value_error": EXISTING_EMAIL.format(self.email)})

        if self.type_plan == ONEVIEW_MONTHLY_MPN or self.type_plan == ONEVIEW_TRIAL_MPN:
            try:
                self._check_contact_account()
            except InvalidCompanyNameFormatError:
                error_params.append({
                    "id": ACCOUNT_COMPANY_NAME,
                    "value_error": COMPANY_NAME_INVALID})
            except InvalidStreetNameFormatError:
                error_params.append({
                    "id": BILLING_STREET,
                    "value_error": STREET_NAME_INVALID})
            except InvalidCityNameFormatError:
                error_params.append({
                    "id": BILLING_CITY,
                    "value_error": CITY_NAME_INVALID})
            except InvalidCountryNameFormatError:
                error_params.append({
                    "id": BILLING_COUNTRY,
                    "value_error": COUNTRY_NAME_INVALID})
            except InvalidStateNameFormatError:
                error_params.append({
                    "id": BILLING_STATE,
                    "value_error": STATE_NAME_INVALID})

        elif self.type_plan == ONEVIEW_MONTHLY_IMPORT_MPN:
            params = self.request_data.params()
            self.msp_account_id = get_param_value(params, MSP_ACCOUNT_ID)
            error_params = self.validate_import_subscription(error_params)
        else:
            self.logger.info("Any Valid Reservation Item was selected.")
            raise OrderingError(RATING_PLAN_PARAMETER_NOT_FOUND)

        return error_params

    def validate_import_subscription(self, error_params: dict) -> dict:
        """
        Check MSP account ID to subscription type import.
        :param error_params:
        :return: dict
        """
        if not self.msp_account_id:
            error_params.append({
                "id": MSP_ACCOUNT_ID,
                "value_error": MSP_ID_INVALID_FORMAT_MESSAGE})
        elif self._check_existing_msp_account_id():
            self.logger.error("MSP Account ID already exists in MalwareBytes.")
            error_params.append({
                "id": MSP_ACCOUNT_ID,
                "value_error": EXISTING_MSP_ACCOUNT_ID.format(self.msp_account_id)})

        return error_params

    def _check_existing_email(self) -> MSPAccount:
        """
        Checks if Email already exist in MalwareBytes.
        :return: MSPAccount
        """
        self.logger.info("Validating if Email Address is using in MalwareBytes.")
        existing_account = AccountGetter(self.account_repository()).execute(Email(self.email))

        return existing_account

    def _check_existing_msp_account_id(self) -> MSPAccount:
        """
        Checks if MSP account already exist in MalwareBytes.
        :return: MSPAccount
        """
        self.logger.info("Validating if MSP Account ID exist in MalwareBytes.")
        existing_account = AccountGetter(self.account_repository()).get_msp_id(
            AccountId(self.msp_account_id))

        return existing_account

    def _check_contact_account(self) -> Account:
        """
        Checks parameters for contact account:
            Account Company Name.
            Billing Street.
            Billing City.
            Billing Country.
        :return: Account
        """
        self.logger.info("Validating contact Account (Account Company Name, Billing Street, "
                         "Billing City, Billing Country).")
        account = PurchaseFlow.get_parameters_account(self)

        return account
