from typing import List

from connect.eaas.core.responses import InteractiveResponse

from connect_malwarebytes.connect.const import (
    ACCOUNT_COMPANY_NAME, BILLING_CITY, BILLING_COUNTRY, BILLING_STREET, CONTACT_EMAIL_NAME,
    CONTACT_FIRST_NAME, CONTACT_LAST_NAME, CONTACT_PHONE_NAME, IMPORT, MSP_ACCOUNT_ID, NEW,
    STATUS_DRAFT,
)
from connect_malwarebytes.connect.messages import RATING_PLAN_PARAMETER_NOT_FOUND
from connect_malwarebytes.connect.request import get_param_value, OrderingError, RatingPlanError
from connect_malwarebytes.flows.flows import ProcessingFlow, ValidationFlow
from connect_malwarebytes.flows.purchase_flow import PurchaseFlow

from malwarebytes.account.application.services import AccountGetter
from malwarebytes.account.domain.exceptions import (
    InvalidCityNameFormatError, InvalidCompanyNameFormatError, InvalidCountryNameFormatError,
    InvalidEmailFormatError, InvalidFirstNameFormatError, InvalidLastNameFormatError,
    InvalidMspIdFormatError, InvalidPhoneFormatError, InvalidStreetNameFormatError,
)
from malwarebytes.account.domain.messages import (
    CITY_NAME_INVALID, COMPANY_NAME_INVALID, COUNTRY_NAME_INVALID, EMAIL_INVALID_FORMAT_MESSAGE,
    EXISTING_EMAIL, FIRST_NAME_INVALID_FORMAT_MESSAGE, INVALID_MSP_ID_FORMAT_MESSAGE,
    LAST_NAME_INVALID_FORMAT_MESSAGE, NOT_EXISTING_EMAIL, NOT_EXISTING_MSP_ACCOUNT_ID,
    PHONE_INVALID_FORMAT_MESSAGE, STREET_NAME_INVALID,
)
from malwarebytes.account.domain.models import (
    Account, AccountId, Email, FirstName, LastName, MSPAccount, Phone,
)

global type_plan, first_name, last_name, phone, email


class PurchaseDraftValidation(ValidationFlow):
    """
    Validate:
    - the parameters required to create (or import) a subscription.
    - Check if email exists or not in MalwareBytes.
    - Validate type of subscription.
    """

    def __init__(self, request, client, logger, config):
        super().__init__(request, client, logger, config)

    def process(self) -> InteractiveResponse:
        """
        Entry point for DraftValidation Flow.
        :return: InteractiveResponse
        """
        self.logger.info(
            f"Starting Validation process for request {self.request_data.id()} with status "
            f"{self.request_data.status()}.")

        self.clear_errors()

        error_params = self._validate_create_subscription()

        for param in error_params:
            self.request_data.update_parameter(
                param_id=param['id'],
                value_error=param['value_error'],
            )

        return InteractiveResponse.done(body=self.request_data.request)

    def clear_errors(self):
        """Clears the value_error field of the parameters used in the flow"""
        self.request_data.update_parameter(param_id=CONTACT_FIRST_NAME, value_error='')
        self.request_data.update_parameter(param_id=CONTACT_LAST_NAME, value_error='')
        self.request_data.update_parameter(param_id=CONTACT_EMAIL_NAME, value_error='')
        self.request_data.update_parameter(param_id=CONTACT_PHONE_NAME, value_error='')
        self.request_data.update_parameter(param_id=ACCOUNT_COMPANY_NAME, value_error='')
        self.request_data.update_parameter(param_id=BILLING_STREET, value_error='')
        self.request_data.update_parameter(param_id=BILLING_CITY, value_error='')
        self.request_data.update_parameter(param_id=BILLING_COUNTRY, value_error='')
        self.request_data.update_parameter(param_id=MSP_ACCOUNT_ID, value_error='')

    def _validate_create_subscription(self) -> List[dict]:
        """
        Validate the parameters required to create (or import) a subscription.
        :return: List[dict]
        """
        if self.request_data.status() == STATUS_DRAFT:
            try:
                # Validate that all params are right and not empty.
                self.type_plan = ProcessingFlow.validate_items(self)
            except (OrderingError, RatingPlanError) as ex:
                self.logger.error(f"There was the following error: {ex}")
                raise

        params = self.request_data.params()

        error_params = []
        try:
            self.first_name = get_param_value(params, CONTACT_FIRST_NAME)
            FirstName(self.first_name)
            self.last_name = get_param_value(params, CONTACT_LAST_NAME)
            LastName(self.last_name)
            self.phone = get_param_value(params, CONTACT_PHONE_NAME)
            Phone(self.phone)
            self.email = get_param_value(params, CONTACT_EMAIL_NAME)
            Email(self.email)
        except InvalidFirstNameFormatError:
            error_params.append({
                "id": CONTACT_FIRST_NAME,
                "value_error": FIRST_NAME_INVALID_FORMAT_MESSAGE.format(self.first_name)})
        except InvalidLastNameFormatError:
            error_params.append({
                "id": CONTACT_LAST_NAME,
                "value_error": LAST_NAME_INVALID_FORMAT_MESSAGE.format(self.last_name)})
        except InvalidPhoneFormatError:
            error_params.append({
                "id": CONTACT_PHONE_NAME,
                "value_error": PHONE_INVALID_FORMAT_MESSAGE.format(self.phone)})
        except InvalidEmailFormatError:
            error_params.append({
                "id": CONTACT_EMAIL_NAME,
                "value_error": EMAIL_INVALID_FORMAT_MESSAGE.format(self.email)})
        else:
            error_params = self._validate_per_type_subscription(error_params)

        return error_params

    def _validate_per_type_subscription(self, error_params) -> dict:
        """
        Validate type of subscription.
        :param error_params:
        :return: dict
        """
        existing_account = self._check_existing_email()

        if self.type_plan == NEW:
            try:
                if existing_account:
                    self.logger.error("Email already exists in MalwareBytes.")
                    error_params.append({
                        "id": CONTACT_EMAIL_NAME,
                        "value_error": EXISTING_EMAIL.format(self.email)})
                else:
                    self._check_contact_account()
            except InvalidCompanyNameFormatError:
                error_params.append({
                    "id": ACCOUNT_COMPANY_NAME,
                    "value_error": COMPANY_NAME_INVALID})
            except InvalidStreetNameFormatError:
                error_params.append({
                    "id": BILLING_STREET,
                    "value_error": STREET_NAME_INVALID})
            except InvalidCityNameFormatError:
                error_params.append({
                    "id": BILLING_CITY,
                    "value_error": CITY_NAME_INVALID})
            except InvalidCountryNameFormatError:
                error_params.append({
                    "id": BILLING_COUNTRY,
                    "value_error": COUNTRY_NAME_INVALID})

        elif self.type_plan == IMPORT:
            self.logger.info("Import Plan was selected.")
            error_params = self.validate_import_subscription(error_params, existing_account)
        else:
            self.logger.info("Any Valid Reservation Item was selected.")
            raise OrderingError(RATING_PLAN_PARAMETER_NOT_FOUND)

        return error_params

    def validate_import_subscription(self, error_params: dict,
                                     existing_account: MSPAccount) -> dict:
        """
        Check MSP account ID to subscription type import.
        :param existing_account:
        :param error_params:
        :return: dict
        """
        if not existing_account:
            self.logger.error("Email does not exists in MalwareBytes.")
            error_params.append({
                "id": CONTACT_EMAIL_NAME,
                "value_error": NOT_EXISTING_EMAIL.format(self.email)})
        else:
            params = self.request_data.params()
            try:
                msp_account_id = AccountId(get_param_value(params, MSP_ACCOUNT_ID)).value
            except InvalidMspIdFormatError:
                self.logger.error("Invalid format for MSP Account ID.")
                error_params.append({
                    "id": MSP_ACCOUNT_ID,
                    "value_error": INVALID_MSP_ID_FORMAT_MESSAGE.format(get_param_value(
                        params, MSP_ACCOUNT_ID))})
                raise

            if existing_account['msp_account_id'] != msp_account_id:
                self.logger.error("MSP Account ID does not exists in MalwareBytes.")
                error_params.append({
                    "id": MSP_ACCOUNT_ID,
                    "value_error": NOT_EXISTING_MSP_ACCOUNT_ID.format(msp_account_id)})

        return error_params

    def _check_existing_email(self) -> MSPAccount:
        """
        Checks if Email already exists in MalwareBytes.
        :return: MSPAccount
        """
        self.logger.info("Validating if Email Address is using in MalwareBytes.")
        existing_account = AccountGetter(self.account_repository()).execute(Email(self.email))

        return existing_account

    def _check_contact_account(self) -> Account:
        """
        Checks parameters for contact account:
            Account Company Name.
            Billing Street.
            Billing City.
            Billing Country.
        :return: Account
        """
        self.logger.info("Validating contact Account (Account Company Name, Billing Street, "
                         "Billing City, Billing Country).")
        account = PurchaseFlow.get_parameters_account(self)

        return account
