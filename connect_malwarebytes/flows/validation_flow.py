from typing import List

from connect.eaas.core.responses import InteractiveResponse

from connect_malwarebytes.connect.const import (
    CONTACT_EMAIL_NAME, MSP_ACCOUNT_ID, STATUS_DRAFT, TRIAL,
)
from connect_malwarebytes.connect.request import (
    get_param_value, OrderingError, RatingPlanError,
)
from connect_malwarebytes.flows.flows import ProcessingFlow, ValidationFlow

from malwarebytes.account.application.services import AccountGetter
from malwarebytes.account.domain.exceptions import (
    InvalidEmailFormatError, InvalidMspIdFormatError,
)
from malwarebytes.account.domain.messages import (
    EMAIL_INVALID_FORMAT_MESSAGE, EXISTING_EMAIL, INVALID_MSP_ID_FORMAT_MESSAGE, MISMATCH_EMAIL,
    NOT_EXISTING_MSP_ACCOUNT_ID,
)
from malwarebytes.account.domain.models import (
    AccountId, Email, MSPAccount,
)

global type_plan, first_name, last_name, phone, email


class PurchaseDraftValidation(ValidationFlow):
    """
    Validate:
    - the parameters required to create (or import) a subscription.
    - Check if email exists or not in MalwareBytes.
    - Validate type of subscription.
    """

    def __init__(self, request, client, logger, config):
        super().__init__(request, client, logger, config)

    def process(self) -> InteractiveResponse:
        """
        Entry point for DraftValidation Flow.
        :return: InteractiveResponse
        """
        self.logger.info(
            f"Starting Validation process for request {self.request_data.id()} with status "
            f"{self.request_data.status()}.")

        self.clear_errors()

        error_params = self._validate_create_subscription()

        for param in error_params:
            self.request_data.update_parameter(
                param_id=param['id'],
                value_error=param['value_error'],
            )

        return InteractiveResponse.done(body=self.request_data.request)

    def clear_errors(self):
        """Clears the value_error field of the parameters used in the flow"""
        self.request_data.update_parameter(param_id=CONTACT_EMAIL_NAME, value_error='')
        self.request_data.update_parameter(param_id=MSP_ACCOUNT_ID, value_error='')

    def _validate_create_subscription(self) -> List[dict]:
        """
        Validate the parameters required to create (or import) a subscription.
        :return: List[dict]
        """
        if self.request_data.status() == STATUS_DRAFT:
            try:
                # Validate that all params are right and not empty.
                self.type_plan = ProcessingFlow.validate_items(self)
            except (OrderingError, RatingPlanError) as ex:
                self.logger.error(f"There was the following error: {ex}")
                raise

        params = self.request_data.params()

        error_params = []
        try:
            self.email = get_param_value(params, CONTACT_EMAIL_NAME)
            Email(self.email)
        except InvalidEmailFormatError:
            error_params.append({
                "id": CONTACT_EMAIL_NAME,
                "value_error": EMAIL_INVALID_FORMAT_MESSAGE.format(self.email)})
        else:
            error_params = self._validate_per_type_subscription(error_params)

        return error_params

    def _validate_per_type_subscription(self, error_params) -> dict:
        """
        Validate type of subscription.
        :param error_params:
        :return: dict
        """

        existing_email_connect = ProcessingFlow.find_email_in_assets(self)
        existing_account = self._check_existing_email()

        # This email is using in Connect and MalwareBytes. You cannot use this email.
        if existing_email_connect and existing_account:
            self.logger.error(f"Email {self.email} already exists in Connect and MalwareBytes.")
            error_params.append({
                "id": CONTACT_EMAIL_NAME,
                "value_error": EXISTING_EMAIL.format(self.email)})
        # This email is using in Connect, but not in MalwareBytes. It is a conflict.
        elif existing_email_connect and not existing_account:
            self.logger.error(
                f"Email {self.email} already exists in Connect, but not in MalwareBytes. "
                f"Please contact the administrator")
            error_params.append({
                "id": CONTACT_EMAIL_NAME,
                "value_error": MISMATCH_EMAIL.format(self.email)})
        # This email not exists in Connect but exists in MalwareBytes. Import Account.
        elif not existing_email_connect and existing_account:
            self.logger.info("Customer is trying to import an account of MalwareBytes.")
            error_params = self.validate_import_subscription(error_params, existing_account)

        return error_params

    def validate_import_subscription(self, error_params: dict,
                                     existing_account: MSPAccount) -> dict:
        """
        Check MSP account ID to subscription type import.
        :param existing_account:
        :param error_params:
        :return: dict
        """

        params = self.request_data.params()

        if self.request_data.billing_type() == TRIAL:
            self.logger.error(
                f"There is a Connect Asset to email {self.email}. You cannot create a "
                f"Trial Subscription for it.")
            error_params.append({
                "id": MSP_ACCOUNT_ID,
                "value_error": INVALID_MSP_ID_FORMAT_MESSAGE.format(get_param_value(
                    params, MSP_ACCOUNT_ID))})
        else:
            try:
                msp_account_id = AccountId(get_param_value(params, MSP_ACCOUNT_ID)).value

                if existing_account['msp_account_id'] != msp_account_id:
                    self.logger.error("MSP Account ID does not exists in MalwareBytes.")
                    error_params.append({
                        "id": MSP_ACCOUNT_ID,
                        "value_error": NOT_EXISTING_MSP_ACCOUNT_ID.format(msp_account_id)})

            except InvalidMspIdFormatError:
                self.logger.error("Invalid format for MSP Account ID.")
                error_params.append({
                    "id": MSP_ACCOUNT_ID,
                    "value_error": INVALID_MSP_ID_FORMAT_MESSAGE.format(get_param_value(
                        params, MSP_ACCOUNT_ID))})

        return error_params

    def _check_existing_email(self) -> MSPAccount:
        """
        Checks if Email already exists in MalwareBytes.
        :return: MSPAccount
        """
        self.logger.info("Validating if Email Address is using in MalwareBytes.")
        existing_account = AccountGetter(self.account_repository()).execute(Email(self.email))

        return existing_account
