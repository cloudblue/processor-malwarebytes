from datetime import datetime

from dateutil import relativedelta

from typing import Union

from connect.eaas.core.responses import BackgroundResponse

from connect_malwarebytes.flows.flows import ProcessingFlow
from connect_malwarebytes.connect import const
from connect_malwarebytes.connect.usage import ReportInfo

from malwarebytes.account.domain.exceptions import NotExistsMspIdError
from malwarebytes.account.infrastructure.exceptions import MBClientException
from malwarebytes.account.application.services import AccountCancel
from malwarebytes.account.domain.models import AccountId
from malwarebytes.account.domain.messages import CANCEL_ACCOUNT


class CancelFlow(ProcessingFlow):

    def process(self) -> BackgroundResponse:
        self.logger.info("Starting Cancel process.")

        try:
            self._cancel_subscription()
        except MBClientException as err:
            self.logger.error(str(err))
            return BackgroundResponse.fail()

        return BackgroundResponse.done()

    def _cancel_subscription(self):
        """
        Cancel Subscription in MalwareBytes.
        """
        msp_account_id = self.request_data.msp_account_id_fulfillment()
        if not msp_account_id:
            raise NotExistsMspIdError("Subscription not contain any MSP Account ID")
        self.logger.info(
            f"Cancelling Subscription in MalwareBytes with MSP Account ID: {msp_account_id}.")

        # We need to check when is the next usage to cancel in this day.
        day_report = self._exists_usage_report()
        if day_report:
            self.logger.info(
                f"The usage report has already been created this month. The cancellation request "
                f"for MSP Account ID {msp_account_id} will be postponed until the next report.")
            current_date = datetime.now()
            date_last_report = datetime(current_date.year, current_date.month, day_report)
            next_month = date_last_report + relativedelta.relativedelta(months=1, day=1)
            seconds_to_next_month = (next_month - date_last_report).total_seconds()

            return BackgroundResponse.slow_process_reschedule(countdown=seconds_to_next_month)

        AccountCancel(self.account_repository()).cancel(AccountId(msp_account_id))

        self.approve_request(self.request_data.id(), "", CANCEL_ACCOUNT.format(msp_account_id))

        self.logger.info(f"Cancel request approved to MSP Account ID: {msp_account_id}.")

    def _exists_usage_report(self) -> Union[bool, int]:
        """
        Check if exists usage report for this month.
        :return:
        """
        request_date = datetime.strptime(self.request_data.creation_date(), const.ASSET_DATE_FORMAT)

        report = ReportInfo(self.client, self.logger).get_last(
            self.request_data.asset_contract_id(), self.request_data.product_id())
        if not report:
            return False

        report_period = datetime.strptime(
            report['events']['created']['at'], const.ASSET_DATE_FORMAT)

        if report_period.month == request_date.month and report_period.year == request_date.year:
            return report_period.day
