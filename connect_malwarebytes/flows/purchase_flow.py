import time
from typing import Tuple, Optional

from connect.eaas.extension import ProcessingResponse
from connect.client import ClientError

from connect_malwarebytes.flows.flows import ProcessingFlow
from connect_malwarebytes.connect.const import (
    CONTACT_FIRST_NAME,
    CONTACT_LAST_NAME,
    CONTACT_EMAIL_NAME,
    CONTACT_PHONE_NAME,
    MSP_ACCOUNT_ID,
    MSP_ACCOUNT_ID_FULFILLMENT,
    VENDOR_ID,
    LICENSE_KEY,
    ONEVIEW_MONTHLY_MPN,
    ONEVIEW_MONTHLY_IMPORT_MPN,
    ONEVIEW_TRIAL_MPN,
    ACCOUNT_COMPANY_NAME,
    BILLING_STREET,
    BILLING_COUNTRY,
    BILLING_CITY,
    MAX_RETRIES
)
from connect_malwarebytes.connect.request import get_param_value, RatingPlanError
from connect_malwarebytes.connect import messages
from malwarebytes.account.domain.exceptions import (
    InvalidFirstNameFormatError,
    InvalidLastNameFormatError,
    InvalidEmailFormatError,
    InvalidPhoneFormatError,
    EmailAlreadyExistsError,
    InvalidAccountToImport,
)

from malwarebytes.account.infrastructure.exceptions import AccountExistingEmailException
from malwarebytes.account.domain.models import (
    AccountId,
    Account,
    Contact,
    FirstName,
    LastName,
    Email,
    Phone,
    CompanyName,
    City,
    Country,
    State,
    Street,
    MSPAccount,
)
from malwarebytes.account.application.services import AccountGetter, AccountCreator

dict_errors = {
    'InvalidFirstNameFormatError': CONTACT_FIRST_NAME,
    'InvalidLastNameFormatError': CONTACT_LAST_NAME,
    'InvalidPhoneFormatError': CONTACT_PHONE_NAME,
    'InvalidEmailFormatError': CONTACT_EMAIL_NAME,
    'AccountExistingEmailException': CONTACT_EMAIL_NAME,
    'EmailAlreadyExistsError': CONTACT_EMAIL_NAME,
}


class PurchaseFlow(ProcessingFlow):

    def process(self) -> ProcessingResponse:
        self.logger.info("Starting Purchase process.")

        if self._is_request_from_migration_tool():
            self.logger.info(
                "The Purchase Request is generated by the migration tool. "
                "Avoided all calls to MalwareBytes API.")
            account = self._get_migration_data()  # TODO Create it.
        else:
            self.logger.info("CREATE ACCOUNT")
            try:
                account, license_key = self._create_subscription()
            except (
                    InvalidFirstNameFormatError, InvalidLastNameFormatError,
                    InvalidEmailFormatError, InvalidPhoneFormatError, EmailAlreadyExistsError,
                    AccountExistingEmailException
            ) as err:
                self.logger.warning(str(err))

                name_error = self._find_error_type(err)

                self.inquire_parameters([{
                    "id": dict_errors[name_error],
                    "value_error": str(err)}])

                return ProcessingResponse.done()

        try:

            self._update_parameters_new_account(account, license_key)

            self.logger.info("Getting Activation Template and Approving the Request.")
            activation_template = self.get_subscription_activation_template()

            self.approve_request(
                self.request_data.id(),
                activation_template)

            self.logger.info(f"Purchase request approved with template {activation_template}.")
        except ClientError as ex:
            self.logger.error(f"There was the following error: {ex.errors}")
            raise

        return ProcessingResponse.done()

    def _update_parameters_new_account(self, account, license_key=None):
        self.logger.info('Setting Connect parameters with the new Account ID and Vendor ID.')

        if account.get('account_id'):
            # In this case is a new subscription trial or paid.
            msp_id = account.get('account_id')
            self.request_data.update_parameter(
                param_id=VENDOR_ID,
                value=account.get('vendor_id'))
        else:
            # In this case is an import subscription.
            msp_id = account.get('msp_account_id')

        self.request_data.update_parameter(
            param_id=MSP_ACCOUNT_ID_FULFILLMENT,
            value=msp_id)
        if license_key is not None:
            self.request_data.update_parameter(
                param_id=LICENSE_KEY,
                value=license_key)

        self.logger.info(
            f"Updating parameters: {MSP_ACCOUNT_ID_FULFILLMENT}={msp_id}; "
            f"{VENDOR_ID}={account.get('vendor_id')}.")

        self.update_parameters(
            self.request_data.id(),
            self.request_data.generate_params_for_update())

    def _is_request_from_migration_tool(self) -> bool:
        """
        Check if the request is from migration tool checking the migration_info parameter.

        Returns
        -------
        bool
            True if the request is from migration tool, False otherwise.
        """
        return bool(self.request_data.migration_info())

    def _create_subscription(self):
        """
        Create a subscription in the service (MalwareBytes) side.

        The subscription can be created (new) or imported (migration) depending
        on Reservation SKU.

        For Import Subscription need get Account ID and Email.

        For New Subscription need get Ordering Params: First Name, Last Name, Email and Phone.
        """
        try:
            mpn = ProcessingFlow.validate_items(self)

            if mpn == ONEVIEW_MONTHLY_MPN:
                return self._process_new_subscription("paid")
            elif mpn == ONEVIEW_TRIAL_MPN:
                return self._process_new_subscription("trial")
            elif mpn == ONEVIEW_MONTHLY_IMPORT_MPN:
                return self._process_import_subscription()

        except RatingPlanError:
            self.logger.error('There is no Rating Plan configured in Connect',
                              'Failing the request.')
            self.fail_request(
                request_id=self.request_data.id(),
                error_message=messages.RATING_PLAN_MISSING)

    def _process_new_subscription(self, term_type: str) -> Tuple[MSPAccount, str]:
        """
        Process a new Subscription
        > Creates the Account
        :param term_type:
        :return: Tuple[MSPAccount, str]
        """
        self.logger.info("Processing a NEW Subscription")
        contact = self._get_parameters_contact()
        account = self.get_parameters_account(term_type)

        self.logger.info("Validating If Account exist by Email Address.")
        existing_account = AccountGetter(self.account_repository()).execute(contact.email)

        if existing_account:
            self.logger.error(
                f'The Account already exists in MalwareBytes with the same '
                f'Email: {contact.email.value}. The Request has to be Rejected.')
            self.logger.debug(f'The MSP Existing Account with same email: {existing_account}')
            raise EmailAlreadyExistsError(
                messages.EMAIL_ALREADY_EXISTS.format(email=contact.email.value))

        self.logger.info("Creating the MSP Account in MalwareBytes")
        msp_account = AccountCreator(self.account_repository()).execute(account, contact)

        license_key = self._get_license_key(msp_account.get('account_id'))

        self.logger.info(f"Account created successfully with ID: {msp_account.get('account_id')}")
        return msp_account, license_key

    def _process_import_subscription(self) -> Tuple[MSPAccount, None]:
        """
        Process an import Subscription
        > Get the Account of MalwareBytes
        :return: Tuple[MSPAccount, None]
        """
        self.logger.info("Processing an Import Subscription")
        params = self.request_data.params()
        email = get_param_value(params, CONTACT_EMAIL_NAME)
        msp_account_id = get_param_value(params, MSP_ACCOUNT_ID)

        self.logger.info("Validating if Email Address exist in MalwareBytes.")
        existing_account = AccountGetter(self.account_repository()).execute(Email(email))

        if not existing_account:
            self.logger.error(
                f'The Account does not exist in MalwareBytes with Email: {email}.')
            raise InvalidAccountToImport(
                messages.ACCOUNT_NOT_EXISTS.format(email=email, id=msp_account_id))
        else:
            if existing_account['msp_account_id'] != msp_account_id:
                self.logger.error(
                    f'The Account does not exist in MalwareBytes with MSP Account ID: {msp_account_id}.')
                raise InvalidAccountToImport(
                    messages.EMAIL_ALREADY_EXISTS.format(email=email, id=msp_account_id))

        return existing_account, None

    def get_parameters_account(self, term_type="trial") -> Account:
        """
        Create Account entity from the request data.

        Returns
        -------
        Account
            The Account entity created from the request data.
        """
        params = self.request_data.params()

        company_name = get_param_value(params, ACCOUNT_COMPANY_NAME)
        street = get_param_value(params, BILLING_STREET)
        city = get_param_value(params, BILLING_CITY)
        country = get_param_value(params, BILLING_COUNTRY)

        if not company_name:
            company_name = self.request_data.asset_company_name()
        if not street:
            street = self.request_data.asset_billing_street()
        if not city:
            city = self.request_data.asset_billing_city()
        if not country:
            country = self.request_data.asset_billing_country()

        return Account(
            company_name=CompanyName(company_name),
            street=Street(street),
            city=City(city),
            country=Country(country.upper()),
            state=State(self.request_data.asset_billing_state()),
            term_type=term_type
        )

    def _get_parameters_contact(self) -> Contact:
        """
        Create Contact entity from the request data.

        Returns
        -------
        Contact
            The Contact entity created from the request data.
        """
        params = self.request_data.params()

        return Contact(
            first_name=FirstName(get_param_value(params, CONTACT_FIRST_NAME)),
            last_name=LastName(get_param_value(params, CONTACT_LAST_NAME)),
            email=Email(get_param_value(params, CONTACT_EMAIL_NAME)),
            phone=Phone(get_param_value(params, CONTACT_PHONE_NAME))
        )

    def _find_error_type(self, err) -> str:
        """
        Find name of exception.
        :param err:
        :return: str
        """
        error_type = str(type(err))
        list_error = error_type.split(".")
        list_error.reverse()
        name_error = list_error[0][:-2]

        return name_error

    def _get_license_key(self, msp_account_id: AccountId) -> str:
        """
        Look for New AccountID to get License Key.
        :param msp_account_id:
        :return: License_key
        """
        license_key = None
        retries = 0
        while license_key is None or retries < MAX_RETRIES:
            # We need wait to can get the license key after create account.
            # It's an expected behaviour in MalwareBytes Api. it takes about 1-3 minutes.
            time.sleep(30)
            retries += 1
            license_key = AccountGetter(self.account_repository()).get_license(
                msp_account_id)

        return license_key
