from typing import Tuple

from connect.eaas.core.responses import BackgroundResponse

from connect_malwarebytes.flows.flows import ProcessingFlow, WithStepExecutor
from connect_malwarebytes.flows.steps.create_account import create_msp_account
from connect_malwarebytes.flows.steps.get_license import get_license_key
from connect_malwarebytes.flows.steps.create_site import create_new_site
from connect_malwarebytes.flows.steps.create_trial_subscription import create_new_trial_subscription
from connect_malwarebytes.flows.steps.approve_request import approve_request
from connect_malwarebytes.connect.const import (
    ACCOUNT_COMPANY_NAME, BILLING_CITY, BILLING_COUNTRY, BILLING_STREET, CONTACT_EMAIL_NAME,
    CONTACT_FIRST_NAME, CONTACT_LAST_NAME, CONTACT_PHONE_NAME, IMPORT, MSP_ACCOUNT_ID,
    MSP_ACCOUNT_ID_FULFILLMENT, NEW, PRODUCTION_ENV, VENDOR_ID,
)
from connect_malwarebytes.connect.request import get_param_value, OrderingError, RatingPlanError
from connect_malwarebytes.connect import messages

from malwarebytes.account.domain.exceptions import InvalidAccountToImport
from malwarebytes.account.domain.models import (
    Account, AccountId, City, CompanyName, Contact, Country, Email, FirstName, LastName,
    MSPAccount, Phone, State, Street,
)
from malwarebytes.account.application.services import AccountGetter


class PurchaseFlow(ProcessingFlow, WithStepExecutor):

    def process(self) -> BackgroundResponse:
        self.logger.info("Starting Purchase process.")
        if self._is_request_from_migration_tool():
            self.logger.info(
                "The Purchase Request is generated by the migration tool. "
                "Avoided all calls to MalwareBytes API.")
            self._get_migration_data()
        else:
            self.logger.info("CREATE ACCOUNT")
            try:
                type_item = ProcessingFlow.validate_items(self)
                if type_item == NEW:
                    self._process_new_subscription()
                elif type_item == IMPORT:
                    self._process_import_subscription()
                else:
                    raise RatingPlanError

            except RatingPlanError:
                self.logger.error('There is no Rating Plan configured in Connect',
                                  'Failing the request.')
                self.fail_request(
                    request_id=self.request_data.id(),
                    error_message=messages.RATING_PLAN_MISSING)
                return BackgroundResponse.fail()
            except OrderingError:
                self.logger.info("Any Valid Reservation Item was selected.")
                self.fail_request(
                    request_id=self.request_data.id(),
                    error_message=messages.RATING_PLAN_PARAMETER_NOT_FOUND)
                return BackgroundResponse.fail()

        return BackgroundResponse.done()

    def _is_request_from_migration_tool(self) -> bool:
        """
        Check if the request is from migration tool checking the migration_info parameter.

        Returns
        -------
        bool
            True if the request is from migration tool, False otherwise.
        """
        return bool(self.request_data.migration_info())

    def _process_new_subscription(self) -> BackgroundResponse:
        """
        Process a new Subscription
        > Creates the Account
        :return: Tuple[MSPAccount, str]
        """
        return self.execute_all([
            create_msp_account,
            get_license_key,
            create_new_site,
            create_new_trial_subscription,
            approve_request,
        ])

    def _process_import_subscription(self) -> Tuple[MSPAccount, None, None]:
        """
        Process an import Subscription
        > Get the Account of MalwareBytes
        :return: Tuple[MSPAccount, None]
        """
        self.logger.info("Processing an Import Subscription")
        params = self.request_data.params()
        email = get_param_value(params, CONTACT_EMAIL_NAME)
        msp_account_id = get_param_value(params, MSP_ACCOUNT_ID)

        self.logger.info("Validating if Email Address exist in MalwareBytes.")
        existing_account = self.check_existing_email(Email(email))

        if not existing_account:
            self.logger.error(
                f'The Account does not exist in MalwareBytes with Email: {email}.')
            raise InvalidAccountToImport(
                messages.ACCOUNT_NOT_EXISTS.format(email=email, id=msp_account_id))
        else:
            if existing_account['msp_account_id'] != msp_account_id:
                self.logger.error(
                    f'The Account does not exist in MalwareBytes with MSP Account ID: '
                    f'{msp_account_id}.')
                raise InvalidAccountToImport(
                    messages.EMAIL_ALREADY_EXISTS.format(email=email, id=msp_account_id))

        return existing_account, None, None

    def _get_migration_data(self):
        """
        Process a migration Subscription
        """

        migration_data = self.request_data.migration_info()

        self.logger.info("Getting parameters of migration info object.")

        account_id = AccountId(migration_data['msp_account_id'])
        vendor_id = AccountId(migration_data['vendor_id'])

        self.logger.info(
            f"Parameters got of migration info object: {MSP_ACCOUNT_ID_FULFILLMENT}={account_id}; "
            f"{VENDOR_ID}={vendor_id}.")

        self.request_data.update_parameter(
            param_id=VENDOR_ID,
            value=vendor_id)

        self.request_data.update_parameter(
            param_id=MSP_ACCOUNT_ID_FULFILLMENT,
            value=account_id)

        self.logger.info(
            f"Updating parameters: {MSP_ACCOUNT_ID_FULFILLMENT}={account_id}; "
            f"{VENDOR_ID}={vendor_id}.")

        self.update_parameters(
            self.request_data.id(),
            self.request_data.generate_params_for_update())

    def get_parameters_account(self) -> Account:
        """
        Create Account entity from the request data.

        Returns
        -------
        Account
            The Account entity created from the request data.
        """
        params = self.request_data.params()

        company_name = get_param_value(params, ACCOUNT_COMPANY_NAME)
        street = get_param_value(params, BILLING_STREET)
        city = get_param_value(params, BILLING_CITY)
        country = get_param_value(params, BILLING_COUNTRY)

        if not company_name:
            company_name = self.request_data.asset_company_name()
        if not street:
            street = self.request_data.asset_billing_street()
        if not city:
            city = self.request_data.asset_billing_city()
        if not country:
            country = self.request_data.asset_billing_country()

        test_account = (self.request_data.environment() == PRODUCTION_ENV)

        return Account(
            company_name=CompanyName(company_name),
            street=Street(street),
            city=City(city),
            country=Country(country.upper()),
            state=State(self.request_data.asset_billing_state()),
            test_account=test_account,
        )

    def _get_parameters_contact(self) -> Contact:
        """
        Create Contact entity from the request data.

        Returns
        -------
        Contact
            The Contact entity created from the request data.
        """
        params = self.request_data.params()

        return Contact(
            first_name=FirstName(get_param_value(params, CONTACT_FIRST_NAME)),
            last_name=LastName(get_param_value(params, CONTACT_LAST_NAME)),
            email=Email(get_param_value(params, CONTACT_EMAIL_NAME)),
            phone=Phone(get_param_value(params, CONTACT_PHONE_NAME)),
        )

    def find_error_type(self, err) -> str:
        """
        Find name of exception.
        :param err:
        :return: str
        """
        error_type = str(type(err))
        list_error = error_type.split(".")
        list_error.reverse()
        name_error = list_error[0][:-2]

        return name_error

    def get_credentials_by_msp_account_id(self, msp_account_id: AccountId, user_id: str) -> \
            Tuple[str, str]:

        # First is get the credentials to can do the calls to create site and trial subscription
        client_id, client_secret = AccountGetter(self.account_repository()).get_credentials(
            msp_account_id, user_id)

        return client_id, client_secret

    def check_existing_email(self, email: Email) -> MSPAccount:
        """
        Checks if Email already exists in MalwareBytes.
        :param email:
        :return:
        """
        self.logger.info("Validating if Email Address is using in MalwareBytes.")
        existing_account = AccountGetter(self.account_repository()).execute(email)

        return existing_account
