import time
from typing import Tuple, Optional

from connect.eaas.extension import ProcessingResponse
from connect.client import ClientError

from connect_malwarebytes.flows.flows import ProcessingFlow
from connect_malwarebytes.connect.const import (
    CONTACT_FIRST_NAME,
    CONTACT_LAST_NAME,
    CONTACT_EMAIL_NAME,
    CONTACT_PHONE_NAME,
    MSP_ACCOUNT_ID,
    MSP_ACCOUNT_ID_FULFILLMENT,
    VENDOR_ID,
    LICENSE_KEY,
    ONEVIEW_MONTHLY_MPN,
    ONEVIEW_MONTHLY_IMPORT_MPN,
    ACCOUNT_COMPANY_NAME,
    BILLING_STREET,
    BILLING_COUNTRY,
    BILLING_CITY,
    MAX_RETRIES,
    PRODUCTION_ENV,
)
from connect_malwarebytes.connect.request import get_param_value, RatingPlanError
from connect_malwarebytes.connect import messages
from malwarebytes.account.domain.exceptions import (
    InvalidFirstNameFormatError,
    InvalidLastNameFormatError,
    InvalidEmailFormatError,
    InvalidPhoneFormatError,
    EmailAlreadyExistsError,
    InvalidAccountToImport,
    LicenseKeyNotFound,
    UsersNotFound,
)

from malwarebytes.account.infrastructure.exceptions import AccountExistingEmailException
from malwarebytes.account.domain.models import (
    AccountId,
    Account,
    Contact,
    FirstName,
    LastName,
    Email,
    Phone,
    CompanyName,
    City,
    Country,
    State,
    Street,
    MSPAccount,
)
from malwarebytes.account.application.services import AccountGetter, AccountCreator, OneViewCreator

dict_errors = {
    'InvalidFirstNameFormatError': CONTACT_FIRST_NAME,
    'InvalidLastNameFormatError': CONTACT_LAST_NAME,
    'InvalidPhoneFormatError': CONTACT_PHONE_NAME,
    'InvalidEmailFormatError': CONTACT_EMAIL_NAME,
    'AccountExistingEmailException': CONTACT_EMAIL_NAME,
    'EmailAlreadyExistsError': CONTACT_EMAIL_NAME,
}


class PurchaseFlow(ProcessingFlow):

    def process(self) -> ProcessingResponse:
        self.logger.info("Starting Purchase process.")

        if self._is_request_from_migration_tool():
            self.logger.info(
                "The Purchase Request is generated by the migration tool. "
                "Avoided all calls to MalwareBytes API.")
            self._get_migration_data()
        else:
            self.logger.info("CREATE ACCOUNT")
            try:
                account, license_key = self._create_subscription()
            except (
                    InvalidFirstNameFormatError, InvalidLastNameFormatError,
                    InvalidEmailFormatError, InvalidPhoneFormatError, EmailAlreadyExistsError,
                    AccountExistingEmailException
            ) as err:
                self.logger.warning(str(err))

                name_error = self._find_error_type(err)

                self.inquire_parameters([{
                    "id": dict_errors[name_error],
                    "value_error": str(err)}])

                return ProcessingResponse.done()

        try:

            if not self._is_request_from_migration_tool():
                self._update_parameters_new_account(account, license_key)

            self.logger.info("Getting Activation Template and Approving the Request.")
            activation_template = self.get_subscription_activation_template()

            self.approve_request(
                self.request_data.id(),
                activation_template)

            self.logger.info(f"Purchase request approved with template {activation_template}.")
        except ClientError as ex:
            self.logger.error(f"There was the following error: {ex.errors}")
            raise

        return ProcessingResponse.done()

    def _update_parameters_new_account(self, account, license_key=None):
        self.logger.info('Setting Connect parameters with the new Account ID and Vendor ID.')

        if account.get('account_id'):
            # In this case is a new subscription.
            msp_id = account.get('account_id')
            self.request_data.update_parameter(
                param_id=VENDOR_ID,
                value=account.get('vendor_id'))
        else:
            # In this case is an import subscription.
            msp_id = account.get('msp_account_id')

        self.request_data.update_parameter(
            param_id=MSP_ACCOUNT_ID_FULFILLMENT,
            value=msp_id)
        if license_key is not None:
            self.request_data.update_parameter(
                param_id=LICENSE_KEY,
                value=license_key)

        self.logger.info(
            f"Updating parameters: {MSP_ACCOUNT_ID_FULFILLMENT}={msp_id}; "
            f"{VENDOR_ID}={account.get('vendor_id')}.")

        self.update_parameters(
            self.request_data.id(),
            self.request_data.generate_params_for_update())

    def _is_request_from_migration_tool(self) -> bool:
        """
        Check if the request is from migration tool checking the migration_info parameter.

        Returns
        -------
        bool
            True if the request is from migration tool, False otherwise.
        """
        return bool(self.request_data.migration_info())

    def _create_subscription(self):
        """
        Create a subscription in the service (MalwareBytes) side.

        The subscription can be created (new) or imported (migration) depending
        on Reservation SKU.

        For Import Subscription need get Account ID and Email.

        For New Subscription need get Ordering Params: First Name, Last Name, Email and Phone.
        """
        try:
            mpn = ProcessingFlow.validate_items(self)

            if mpn == ONEVIEW_MONTHLY_MPN:
                return self._process_new_subscription()
            elif mpn == ONEVIEW_MONTHLY_IMPORT_MPN:
                return self._process_import_subscription()

        except RatingPlanError:
            self.logger.error('There is no Rating Plan configured in Connect',
                              'Failing the request.')
            self.fail_request(
                request_id=self.request_data.id(),
                error_message=messages.RATING_PLAN_MISSING)

    def _process_new_subscription(self) -> Tuple[MSPAccount, str]:
        """
        Process a new Subscription
        > Creates the Account
        :return: Tuple[MSPAccount, str]
        """
        self.logger.info("Processing a NEW Subscription")
        contact = self._get_parameters_contact()
        account = self.get_parameters_account()

        self.logger.info("Validating If Account exist by Email Address.")
        existing_account = AccountGetter(self.account_repository()).execute(contact.email)

        if existing_account:
            self.logger.error(
                f'The Account already exists in MalwareBytes with the same '
                f'Email: {contact.email.value}. The Request has to be Rejected.')
            self.logger.debug(f'The MSP Existing Account with same email: {existing_account}')
            raise EmailAlreadyExistsError(
                messages.EMAIL_ALREADY_EXISTS.format(email=contact.email.value))

        self.logger.info("Creating the MSP Account in MalwareBytes")
        msp_account = AccountCreator(self.account_repository()).execute(account, contact)

        self.msp_account_id = msp_account.get('account_id')

        license_key, user_id = self._get_additional_info()

        self._create_site_and_trial_subscription(user_id, contact,
                                                 account)

        self.logger.info(f"Account created successfully with ID: {self.msp_account_id}")
        return msp_account, license_key

    def _process_import_subscription(self) -> Tuple[MSPAccount, None]:
        """
        Process an import Subscription
        > Get the Account of MalwareBytes
        :return: Tuple[MSPAccount, None]
        """
        self.logger.info("Processing an Import Subscription")
        params = self.request_data.params()
        email = get_param_value(params, CONTACT_EMAIL_NAME)
        msp_account_id = get_param_value(params, MSP_ACCOUNT_ID)

        self.logger.info("Validating if Email Address exist in MalwareBytes.")
        existing_account = AccountGetter(self.account_repository()).execute(Email(email))

        if not existing_account:
            self.logger.error(
                f'The Account does not exist in MalwareBytes with Email: {email}.')
            raise InvalidAccountToImport(
                messages.ACCOUNT_NOT_EXISTS.format(email=email, id=msp_account_id))
        else:
            if existing_account['msp_account_id'] != msp_account_id:
                self.logger.error(
                    f'The Account does not exist in MalwareBytes with MSP Account ID: {msp_account_id}.')
                raise InvalidAccountToImport(
                    messages.EMAIL_ALREADY_EXISTS.format(email=email, id=msp_account_id))

        return existing_account, None

    def _get_migration_data(self):
        """
        Process a migration Subscription
        """

        migration_data = self.request_data.migration_info_object()

        self.logger.info("Getting parameters of migration info object.")

        account_id = AccountId(migration_data['msp_account_id'])
        vendor_id = AccountId(migration_data['vendor_id'])

        self.logger.info(
            f"Parameters got of migration info object: {MSP_ACCOUNT_ID_FULFILLMENT}={account_id}; "
            f"{VENDOR_ID}={vendor_id}.")

        self.request_data.update_parameter(
            param_id=VENDOR_ID,
            value=vendor_id)

        self.request_data.update_parameter(
            param_id=MSP_ACCOUNT_ID_FULFILLMENT,
            value=account_id)

        self.logger.info(
            f"Updating parameters: {MSP_ACCOUNT_ID_FULFILLMENT}={account_id}; "
            f"{VENDOR_ID}={vendor_id}.")

        self.update_parameters(
            self.request_data.id(),
            self.request_data.generate_params_for_update())

    def get_parameters_account(self) -> Account:
        """
        Create Account entity from the request data.

        Returns
        -------
        Account
            The Account entity created from the request data.
        """
        params = self.request_data.params()

        company_name = get_param_value(params, ACCOUNT_COMPANY_NAME)
        street = get_param_value(params, BILLING_STREET)
        city = get_param_value(params, BILLING_CITY)
        country = get_param_value(params, BILLING_COUNTRY)

        if not company_name:
            company_name = self.request_data.asset_company_name()
        if not street:
            street = self.request_data.asset_billing_street()
        if not city:
            city = self.request_data.asset_billing_city()
        if not country:
            country = self.request_data.asset_billing_country()

        test_account = (self.request_data.environment() == PRODUCTION_ENV)

        return Account(
            company_name=CompanyName(company_name),
            street=Street(street),
            city=City(city),
            country=Country(country.upper()),
            state=State(self.request_data.asset_billing_state()),
            test_account=test_account
        )

    def _get_parameters_contact(self) -> Contact:
        """
        Create Contact entity from the request data.

        Returns
        -------
        Contact
            The Contact entity created from the request data.
        """
        params = self.request_data.params()

        return Contact(
            first_name=FirstName(get_param_value(params, CONTACT_FIRST_NAME)),
            last_name=LastName(get_param_value(params, CONTACT_LAST_NAME)),
            email=Email(get_param_value(params, CONTACT_EMAIL_NAME)),
            phone=Phone(get_param_value(params, CONTACT_PHONE_NAME))
        )

    def _find_error_type(self, err) -> str:
        """
        Find name of exception.
        :param err:
        :return: str
        """
        error_type = str(type(err))
        list_error = error_type.split(".")
        list_error.reverse()
        name_error = list_error[0][:-2]

        return name_error

    def _get_additional_info(self) -> Tuple[str, str]:
        """
        Look for New AccountID to get License Key and User ID.
        :return: Tuple[str, str]
        """
        condition = False
        retries = 0
        while not condition and retries < MAX_RETRIES:
            # We need wait to can get the license key after create account.
            # It's an expected behaviour in MalwareBytes Api. it takes about 1-3 minutes.
            time.sleep(60)
            retries += 1
            msp_account = AccountGetter(self.account_repository()).get_msp_account(
                self.msp_account_id)

            if msp_account and msp_account.get('users') and msp_account.get(
                    'license_key'):
                condition = True

        if not msp_account.get('license_key'):
            raise LicenseKeyNotFound(
                messages.LICENSE_KEY_NOT_FOUND.format(id=self.msp_account_id))

        if not msp_account.get('users'):
            raise UsersNotFound(
                messages.USERS_NOT_FOUND.format(id=self.msp_account_id))

        return msp_account.get('license_key'), msp_account.get('users')[0].get('user_id')

    def _create_site_and_trial_subscription(self, user_id: str, contact: Contact,
                                            account: Account) -> str:
        """
        Create New Site for MSP Account ID and Trial Subscription.
        :param msp_account_id:
        :return: License_key
        """

        # First we need to get client_id and client_secret to can do the call to OneView API.
        client_id, client_secret = self.get_credentials_by_msp_account_id(self.msp_account_id,
                                                                          user_id)

        body_new_site = {
            "company_name": account.company_name.value,
            "firstname": contact.first_name.value,
            "lastname": contact.last_name.value,
            "email": contact.email.value,
            "account_owner": [
                contact.email.value
            ],
            "site_end_date": "2023-05-25"  # TODO What date I need put here??
        }

        # Here call to API to create a new site.
        OneViewCreator(self.oneview_repository(client_id, client_secret)).create_site(body_new_site)

        body_trial_subscription = {
            "product": self.request_data.trial_product(),
            "machine_type": self.request_data.trial_machine(),
            "term_type": "paid",
            "term_length": 0,
            "allocations": {
                "ir": 0,
                "ep": 0,
                "edr": 0,
                "eps": 0,
                "edrs": 0
            }
        }

        # Here call to API to create a trial_subscription.
        OneViewCreator(
            self.oneview_repository(client_id, client_secret)).create_trial_subscription(
            self.msp_account_id, body_trial_subscription)

    def get_credentials_by_msp_account_id(self, msp_account_id: AccountId, user_id: AccountId) -> \
            Tuple[str, str]:

        # First is get the credentials to can do the calls to create site and trial subscription
        client_id, client_secret = AccountGetter(self.account_repository()).get_credentials(
            msp_account_id, user_id)

        return client_id, client_secret
