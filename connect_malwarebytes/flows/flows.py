from abc import abstractmethod
from typing import List, Optional, Union

from connect.eaas.core.responses import BackgroundResponse, InteractiveResponse
from connect.client import ClientError
from malwarebytes.account.domain.contracts import AccountRepository, OneViewRepository
from malwarebytes.account.infrastructure.http import MBAccountRepository, OneviewRepository
from malwarebytes.account.infrastructure.http import APIClient, APIClientOneView

from connect_malwarebytes.connect import const
from connect_malwarebytes.connect.logger import ExtensionLoggerAdapter
from connect_malwarebytes.connect.request import (
    ConfigurationError, OrderingError, RatingPlanError, RequestParser,
)
from connect_malwarebytes.connect.messages import (
    ITEM_TYPE_NOT_VALID, RATING_PLAN_PARAMETER_NOT_FOUND, RATING_PLAN_PARAMETER_NOT_VALID,
)


class Flow:

    def __init__(self, request, client, logger, config):

        self.request_data = RequestParser.get_instance(request, config)

        request_id = request.get('id', '')
        self.logger = ExtensionLoggerAdapter(logger.logger, logger.extra, request_id)
        self.client = client
        self.config = config

    def handle(self) -> Optional[
        Union[BackgroundResponse, InteractiveResponse]
    ]:
        """Handles the requests process"""
        try:
            return self.process()

        except ConfigurationError as ex:
            self.logger.error(str(ex))
            raise

        except Exception as ex:
            self.logger.error('Something unexpected has happened, please check the exception stack '
                              'trace for more information: {}'.format(ex))
            raise

    @abstractmethod
    def process(self):  # pragma: no cover
        pass

    def inquire_parameters(self, params: List[dict]) -> None:
        for param in params:
            self.request_data.update_parameter(
                param_id=param[const.ID],
                value_error=param[const.VALUE_ERROR],
            )

        self.update_parameters(self.request_data.id(),
                               self.request_data.generate_params_for_update())
        self.inquire_request(self.request_data.id())

        return BackgroundResponse.done()

    def approve_request(self, request_id: str, template_id: str, message: str = "") -> None:
        try:
            if not template_id:
                payload = {const.TILE_ID: message}
            else:
                payload = {const.TEMPLATE_ID: template_id, const.TILE_ID: message}
            self.client.requests[request_id](const.APPROVE_ACTION).post(
                payload=payload)

            self.request_data.set_status('approved')
        except ClientError as ex:
            # Capturing Connect response "REQ_003 - Only pending and inquiring requests can
            # be approved"
            if ex.error_code == const.CONNECT_ERROR_CODE_APPROVE_NOT_PENDING_INQUIRING:
                return
            raise

        return BackgroundResponse.done()

    def fail_request(self, request_id: str, error_message: str) -> None:
        self.client.requests[request_id](const.FAIL_ACTION).post(
            payload={const.KEY_REASON: error_message})

        self.request_data.set_status('failed')
        self.request_data.set_reason(error_message)

        return BackgroundResponse.done()

    def inquire_request(self, request_id: str) -> None:
        template = self.client.products[self.request_data.product_id()].templates.filter(
            scope=const.ASSET,
            type=const.INQUIRE_ACTION,
        ).first()

        self.client.requests[request_id](const.INQUIRE_ACTION).post(
            payload={const.TEMPLATE_ID: template['id']})

        self.request_data.set_status('inquiring')

        return BackgroundResponse.done()

    def get_subscription_activation_template(self) -> str:
        return self.request_data.subscription_activation_template_id()

    def get_msp_account_id_fulfillment(self) -> str:
        return self.request_data.msp_account_id_fulfillment()

    def get_license_key(self) -> str:
        return self.request_data.license_key()

    def get_user_id(self) -> str:
        return self.request_data.user_id()

    def get_site_id(self) -> str:
        return self.request_data.site_id()

    def update_parameters(self, request_id: str, params: dict) -> dict:
        return self.client.requests[request_id].update(payload=params)

    def api_client(self) -> APIClient:

        return APIClient(
            mb_oauth_url=self.request_data.api_url(),
            mb_oauth_client_id=self.request_data.api_client_id(),
            mb_oauth_client_secret=self.request_data.api_secret(),
            mb_api_url=self.request_data.api_url(),
            logger=self.logger)

    def api_client_oneview(self, client_id, client_secret) -> APIClientOneView:

        return APIClientOneView(
            mb_oauth_url=self.request_data.oneview_api_url(),
            mb_oauth_client_id=client_id,
            mb_oauth_client_secret=client_secret,
            mb_api_url=self.request_data.oneview_api_url(),
            logger=self.logger)

    def account_repository(self) -> AccountRepository:
        return MBAccountRepository(self.api_client(), self.logger)

    def oneview_repository(self, client_id, client_secret) -> OneViewRepository:
        return OneviewRepository(self.api_client_oneview(client_id, client_secret), self.logger)

    def get_asset(self, asset_id: str) -> dict:
        return self.client.assets[asset_id].get()


class ProcessingFlow(Flow):
    @property
    def product_id(self):
        return self.config[const.PRODUCT_ID]

    """
    A subclass for standard business flows (Purchase, Change, Cancel, Suspend, Resume, Tier Config)
    """

    def handle(self) -> BackgroundResponse:
        try:
            result = super().handle()

        except ConfigurationError as ex:
            result = BackgroundResponse.fail(str(ex))

        return result

    def validate_items(self) -> Optional[str]:
        """
        Checks if product items are correctly configured
        For 'Rating Plan - Reservation' only one must be added.
        """
        self.logger.info('Checking item values.')

        if not self.request_data.rating_plan_item():
            self.logger.error(f'There is no Rating Plan item in request {self.request_data.id()}.')
            raise RatingPlanError(RATING_PLAN_PARAMETER_NOT_FOUND)

        cont = 0
        reservation_item = ""
        all_items = self.request_data.rating_plan_items()
        for item in all_items:
            if item.get('item_type') == const.RESERVATION_ITEM:
                cont += 1
                reservation_item = item

        # Check if there is only one reservation item.
        if cont <= 1 and reservation_item != "":
            params_item = item.get('params')
            for param in params_item:
                if param.get('id') == const.TYPE_ITEM:
                    return param.get('value')
            raise OrderingError(ITEM_TYPE_NOT_VALID)

        # If there are more than one Item type Reservation show an error.
        if cont > 1:
            self.logger.error(f'There are more than one Rating Plan item in request '
                              f'{self.request_data.id()}.')

        raise OrderingError(RATING_PLAN_PARAMETER_NOT_VALID)


class ValidationFlow(Flow):
    """A subclass for validation flows"""

    def handle(self) -> InteractiveResponse:
        try:
            return super().handle()
        except ConfigurationError:
            if self.request_data.status() == const.STATUS_DRAFT:
                return InteractiveResponse.done(body=self.request_data.request)
            return InteractiveResponse.fail()


class ActionFlow(Flow):
    """A subclass for product actions"""

    def __init__(self, request, client, logger, config):
        super().__init__(request, client, logger, config)
        self.request_data = request

    def handle(self) -> InteractiveResponse:
        try:
            return super().handle()
        except ConfigurationError:
            return InteractiveResponse.done(body='Error')


class WithStepExecutor(object):
    """A mixin for executing multiple steps"""

    def execute_all(self, functions: List[callable]) -> Optional[Union[
        BackgroundResponse, InteractiveResponse,
    ]]:
        for function in functions:
            result = function(self)

            if isinstance(result, (BackgroundResponse, InteractiveResponse)):
                return result

        if isinstance(self, ValidationFlow):
            return InteractiveResponse.done(body=self.request_data.request)

        return BackgroundResponse.done()
