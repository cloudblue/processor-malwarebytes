from abc import abstractmethod
from typing import List, Optional, Union

from connect.eaas.extension import ProcessingResponse, ProductActionResponse, ValidationResponse
from connect.client import ClientError

from malwarebytes.account.domain.contracts import AccountRepository
from malwarebytes.account.infrastructure.http import MBAccountRepository
from malwarebytes.account.infrastructure.http import APIClient

from connect_malwarebytes.connect import const
from connect_malwarebytes.connect.logger import ExtensionLoggerAdapter
from connect_malwarebytes.connect.request import ConfigurationError, RequestParser


class Flow:

    def __init__(self, request, client, logger, config):
        self.request_data = RequestParser.get_instance(request, config)

        request_id = request.get('id', '')
        self.logger = ExtensionLoggerAdapter(logger.logger, logger.extra, request_id)
        self.client = client
        self.config = config

    def handle(self) -> Optional[
        Union[ProcessingResponse, ValidationResponse, ProductActionResponse]
    ]:
        """Handles the requests process"""
        try:
            return self.process()

        except ConfigurationError as ex:
            self.logger.error(str(ex))
            raise

        except Exception as ex:
            self.logger.error("Unhandled exception: {}".format(ex))
            raise

    @abstractmethod
    def process(self):  # pragma: no cover
        pass

    def inquire_parameters(self, params: List[dict]) -> None:
        for param in params:
            self.request_data.update_parameter(
                param_id=param[const.ID],
                value_error=param[const.VALUE_ERROR],
            )

        self.update_parameters(self.request_data.id(),
                               self.request_data.generate_params_for_update())
        self.inquire_request(self.request_data.id())

    def approve_request(self, request_id: str, template_id: str) -> None:
        try:
            self.client.requests[request_id](const.APPROVE_ACTION).post(
                payload={const.TEMPLATE_ID: template_id})

            self.request_data.set_status('approved')
        except ClientError as ex:
            # Capturing Connect response "REQ_003 - Only pending and inquiring requests can be approved"
            if ex.error_code == const.CONNECT_ERROR_CODE_APPROVE_NOT_PENDING_INQUIRING:
                return
            raise

    def inquire_request(self, request_id: str) -> None:
        template = self.client.products[self.request_data.product_id()].templates.filter(
            scope=const.ASSET,
            type=const.INQUIRE_ACTION,
        ).first()

        self.client.requests[request_id](const.INQUIRE_ACTION).post(
            payload={const.TEMPLATE_ID: template['id']})

        self.request_data.set_status('inquiring')

    def get_subscription_activation_template(self) -> str:
        return self.request_data.subscription_activation_template_id()

    def update_parameters(self, request_id: str, params: dict) -> dict:
        return self.client.requests[request_id].update(payload=params)

    def api_client(self) -> APIClient:

        return APIClient(
            mb_oauth_url=self.request_data.api_url(),
            mb_oauth_client_id=self.request_data.api_client_id(),
            mb_oauth_client_secret=self.request_data.api_secret(),
            mb_api_url=self.request_data.api_url(),
            logger=self.logger)

    def account_repository(self) -> AccountRepository:
        return MBAccountRepository(self.api_client(), self.logger)


class ProcessingFlow(Flow):
    @property
    def product_id(self):
        return self.config[const.PRODUCT_ID]

    """A subclass for standard business flows (Purchase, Change, Cancel, Suspend, Resume, 
    Tier Config)"""

    def handle(self) -> ProcessingResponse:
        try:
            result = super().handle()

        except ConfigurationError as ex:
            result = ProcessingResponse.fail(str(ex))

        return result
