from abc import abstractmethod
from typing import List, Optional, Union

from connect.eaas.core.responses import InteractiveResponse
from connect.eaas.extension import ProcessingResponse, ProductActionResponse, ValidationResponse
from connect.client import ClientError

from malwarebytes.account.domain.contracts import AccountRepository, OneViewRepository
from malwarebytes.account.infrastructure.http import MBAccountRepository, OneviewRepository
from malwarebytes.account.infrastructure.http import APIClient, APIClientOneView

from connect_malwarebytes.connect import const
from connect_malwarebytes.connect.logger import ExtensionLoggerAdapter
from connect_malwarebytes.connect.request import ConfigurationError, RequestParser, OrderingError
from connect_malwarebytes.connect.messages import RATING_PLAN_PARAMETER_NOT_VALID, \
    RATING_PLAN_PARAMETER_NOT_FOUND


class Flow:

    def __init__(self, request, client, logger, config):
        self.request_data = RequestParser.get_instance(request, config)

        request_id = request.get('id', '')
        self.logger = ExtensionLoggerAdapter(logger.logger, logger.extra, request_id)
        self.client = client
        self.config = config

    def handle(self) -> Optional[
        Union[ProcessingResponse, ValidationResponse, ProductActionResponse]
    ]:
        """Handles the requests process"""
        try:
            return self.process()

        except ConfigurationError as ex:
            self.logger.error(str(ex))
            raise

        except Exception as ex:
            self.logger.error("Unhandled exception: {}".format(ex))
            raise

    @abstractmethod
    def process(self):  # pragma: no cover
        pass

    def inquire_parameters(self, params: List[dict]) -> None:
        for param in params:
            self.request_data.update_parameter(
                param_id=param[const.ID],
                value_error=param[const.VALUE_ERROR],
            )

        self.update_parameters(self.request_data.id(),
                               self.request_data.generate_params_for_update())
        self.inquire_request(self.request_data.id())

    def approve_request(self, request_id: str, template_id: str, message: str = "") -> None:
        try:
            if not template_id:
                payload = {const.TILE_ID: message}
            else:
                payload = {const.TEMPLATE_ID: template_id, const.TILE_ID: message}
            self.client.requests[request_id](const.APPROVE_ACTION).post(
                payload=payload)

            self.request_data.set_status('approved')
        except ClientError as ex:
            # Capturing Connect response "REQ_003 - Only pending and inquiring requests can be approved"
            if ex.error_code == const.CONNECT_ERROR_CODE_APPROVE_NOT_PENDING_INQUIRING:
                return
            raise

    def fail_request(self, request_id: str, error_message: str) -> None:
        self.client.requests[request_id](const.FAIL_ACTION).post(
            payload={const.KEY_REASON: error_message})

        self.request_data.set_status('failed')
        self.request_data.set_reason(error_message)

    def inquire_request(self, request_id: str) -> None:
        template = self.client.products[self.request_data.product_id()].templates.filter(
            scope=const.ASSET,
            type=const.INQUIRE_ACTION,
        ).first()

        self.client.requests[request_id](const.INQUIRE_ACTION).post(
            payload={const.TEMPLATE_ID: template['id']})

        self.request_data.set_status('inquiring')

    def get_subscription_activation_template(self) -> str:
        return self.request_data.subscription_activation_template_id()

    def update_parameters(self, request_id: str, params: dict) -> dict:
        return self.client.requests[request_id].update(payload=params)

    def api_client(self) -> APIClient:

        return APIClient(
            mb_oauth_url=self.request_data.api_url(),
            mb_oauth_client_id=self.request_data.api_client_id(),
            mb_oauth_client_secret=self.request_data.api_secret(),
            mb_api_url=self.request_data.api_url(),
            logger=self.logger)

    def api_client_oneview(self, client_id, client_secret) -> APIClientOneView:

        return APIClientOneView(
            mb_oauth_url=self.request_data.oneview_api_url(),
            mb_oauth_client_id=client_id,
            mb_oauth_client_secret=client_secret,
            mb_api_url=self.request_data.oneview_api_url(),
            logger=self.logger)

    def account_repository(self) -> AccountRepository:
        return MBAccountRepository(self.api_client(), self.logger)

    def oneview_repository(self, client_id, client_secret) -> OneViewRepository:
        return OneviewRepository(self.api_client_oneview(client_id, client_secret), self.logger)

    def get_asset(self, asset_id: str) -> dict:
        return self.client.assets[asset_id].get()


class ProcessingFlow(Flow):
    @property
    def product_id(self):
        return self.config[const.PRODUCT_ID]

    """A subclass for standard business flows (Purchase, Change, Cancel, Suspend, Resume, 
    Tier Config)"""

    def handle(self) -> ProcessingResponse:
        try:
            result = super().handle()

        except ConfigurationError as ex:
            result = ProcessingResponse.fail(str(ex))

        return result

    def validate_items(self) -> Optional[str]:
        """
        Checks if product items are correctly configured
        For 'Rating Plan - Reservation' only one must be added.
        """
        self.logger.info('Checking item values.')

        if not self.request_data.rating_plan_item():
            self.logger.error(f'There is no Rating Plan item in request {self.request_data.id()}.')
            raise OrderingError(RATING_PLAN_PARAMETER_NOT_FOUND)

        cont = 0
        reservation_item = ""
        all_items = self.request_data.rating_plan_items()
        for item in all_items:
            if item.get('item_type') == const.RESERVATION_ITEM:
                cont += 1
                reservation_item = item

        # Check if there is only one reservation item.
        if cont <= 1 and reservation_item != "":
            return reservation_item.get('mpn')

        # If there are more than one Item type Reservation show an error.
        if cont > 1:
            self.logger.error(f'There are more than one Rating Plan item in request '
                              f'{self.request_data.id()}.')

        raise OrderingError(RATING_PLAN_PARAMETER_NOT_VALID)


class ActionFlow(Flow):
    """A subclass for product actions"""

    def __init__(self, request, client, logger, config):
        super().__init__(request, client, logger, config)
        self.request_data = request

    def handle(self) -> InteractiveResponse:
        try:
            return super().handle()
        except ConfigurationError:
            return InteractiveResponse.done(body='Error')
