from abc import abstractmethod
from typing import Optional, Union

from connect.eaas.extension import ProcessingResponse, ProductActionResponse, ValidationResponse

from malwarebytes.shared.domain.exceptions import InvalidIdFormatError

from connect_malwarebytes.connect import const
from connect_malwarebytes.connect.logger import ExtensionLoggerAdapter
from connect_malwarebytes.connect.request import ConfigurationError, RequestParser


class Flow:
    def __init__(self, request, client, logger, config):
        self.request_data = RequestParser.get_instance(request, config)

        request_id = request.get('id', '')
        self.logger = ExtensionLoggerAdapter(logger.logger, logger.extra, request_id)
        self.client = client
        self.config = config

    def handle(self) -> Optional[
        Union[ProcessingResponse, ValidationResponse, ProductActionResponse]]:
        """Handles the request process"""
        try:
            return self.process()

        except ConfigurationError as ex:
            self.logger.error(str(ex))
            raise

        except Exception as ex:
            self.logger.error("Unhandled exception: {}".format(ex))
            raise

    @abstractmethod
    def process(self):  # pragma: no cover
        pass

    """
    def inquire_parameters(self, params: List[dict]) -> None:
        for param in params:
            self.request_data.update_parameter(
                param_id=param[const.ID],
                value_error=param[const.VALUE_ERROR],
            )

        self.update_parameters(self.request_data.id(), self.request_data.generate_params_for_update())
        self.inquire_request(self.request_data.id())

    def approve_request(self, request_id: str, template_id: str) -> None:
        try:
            self.client.requests[request_id](const.APPROVE_ACTION).post(
                payload={const.TEMPLATE_ID: template_id})

            self.request_data.set_status('approved')
        except ClientError as ex:
            # Capturing Connect response "REQ_003 - Only pending and inquiring requests can be approved"
            if ex.error_code == const.CONNECT_ERROR_CODE_APPROVE_NOT_PENDING_INQUIRING:
                return
            raise

    def fail_request(self, request_id: str, error_message: str) -> None:
        self.client.requests[request_id](const.FAIL_ACTION).post(
            payload={const.KEY_REASON: error_message})

        self.request_data.set_status('failed')
        self.request_data.set_reason(error_message)

    def inquire_request(self, request_id: str) -> None:
        template = self.client.products[self.request_data.product_id()].templates.filter(
            scope=const.ASSET,
            type=const.INQUIRE_ACTION,
        ).first()

        self.client.requests[request_id](const.INQUIRE_ACTION).post(
            payload={const.TEMPLATE_ID: template['id']})

        self.request_data.set_status('inquiring')

    def get_subscription_activation_template(self) -> str:
        return self.request_data.subscription_activation_template_id()

    def update_parameters(self, request_id: str, params: dict) -> dict:
        return self.client.requests[request_id].update(payload=params)

    def api_client(self) -> APIClient:
        return APIClient(
            host=self.request_data.host(),
            port=self.request_data.port(),
            username=self.request_data.username(),
            password=self.request_data.password(),
            logger=self.logger)

    def s3_client(self):
        return S3Client(
            s3_endpoint_url=self.request_data.s3_endpoint_host(),
            logger=self.logger)

    def user_repository(self):
        return CloudianUserRepository(self.api_client(), self.logger)

    def group_repository(self) -> GroupRepository:
        return CloudianGroupRepository(self.api_client(), self.s3_client(), self.user_repository(), self.logger)
    """


class ProcessingFlow(Flow):
    @property
    def product_id(self):
        return self.config[const.PRODUCT_ID]

    """A subclass for standard business flows (Purchase, Change, Cancel, Suspend, Resume, 
    Tier Config)"""

    def handle(self) -> ProcessingResponse:
        try:
            result = super().handle()

        except ConfigurationError as ex:
            result = ProcessingResponse.fail(str(ex))

        except InvalidIdFormatError as ex:
            self.logger.error(
                f"Invalid GroupId {self.request_data.group_id()}. Failing the request.")
            self.fail_request(self.request_data.id(), str(ex))
            result = ProcessingResponse.done()

        return result

    """
    def get_storage_quota(self) -> KBytes:
        return KBytes(self.request_data.qos_limit() * const.KB_BY_GB)

    def get_rating_plan_id(self) -> RatingPlanId:
        ""
        Get the Rating Plan ID
    data.

        Returns
        -------
        str
            The Rating Plan ID
    data.
        ""
        rating_plan_id = self.request_data.rating_plan_id()
        if not rating_plan_id:
            raise RatingPlanError(messages.RATING_PLAN_MISSING)

        return RatingPlanId(self.request_data.rating_plan_id())

    def get_reporting_schema(self) -> str:
        ""
        Returns the reporting schema for the given product.

        Returns
        -------
        str
            Reporting schema.
        ""
        return ProductInfo(self.client, self.logger).get(self.product_id)['capabilities']['ppu']['schema']

    def get_group_id(self) -> GroupId:
        group_id = self.request_data.group_id()

        if self.get_reporting_schema().lower() == const.QT_RATING_SCHEMA.lower() and group_id.startswith(const.QT_RATING_SCHEMA):
            group_id = group_id[2:]

        return GroupId(group_id)
    """
