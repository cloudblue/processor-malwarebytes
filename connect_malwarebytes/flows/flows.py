from abc import abstractmethod
from typing import Any, Dict, List, Optional, Tuple, Union

from connect.eaas.core.responses import BackgroundResponse, InteractiveResponse
from connect.client import ClientError
from malwarebytes.account.application.services import AccountGetter
from malwarebytes.account.domain.contracts import AccountRepository, OneViewRepository
from malwarebytes.account.domain.exceptions import InvalidMspIdFormatError
from malwarebytes.account.domain.messages import (
    EXISTING_EMAIL, INVALID_MSP_ID_FORMAT_MESSAGE, MISMATCH_EMAIL, NOT_EXISTING_MSP_ACCOUNT_ID,
)
from malwarebytes.account.domain.models import AccountId, Email, MSPAccount
from malwarebytes.account.infrastructure.http import MBAccountRepository, OneviewRepository
from malwarebytes.account.infrastructure.http import APIClient, APIClientOneView

from connect_malwarebytes.connect import const
from connect_malwarebytes.connect.logger import ExtensionLoggerAdapter
from connect_malwarebytes.connect.request import (
    AssetsGetter, ConfigurationError, OrderingError, RatingPlanError, RequestParser,
)
from connect_malwarebytes.connect.messages import (
    ITEM_TYPE_NOT_VALID, RATING_PLAN_PARAMETER_NOT_FOUND, RATING_PLAN_PARAMETER_NOT_VALID,
)


class Flow:

    def __init__(self, request, client, logger, config):

        self.request_data = RequestParser.get_instance(request, config)

        request_id = request.get('id', '')
        self.logger = ExtensionLoggerAdapter(logger.logger, logger.extra, request_id)
        self.client = client
        self.config = config

    def handle(self) -> Optional[
        Union[BackgroundResponse, InteractiveResponse]
    ]:  # pragma: no cover
        """Handles the requests process"""
        try:
            return self.process()

        except ConfigurationError as ex:
            self.logger.error(str(ex))
            raise

        except Exception as ex:
            self.logger.error('Something unexpected has happened, please check the exception stack '
                              'trace for more information: {ex}'.format(ex=ex))
            raise

    @abstractmethod
    def process(self):  # pragma: no cover
        pass

    def approve_request(self, request_id: str, template_id: str, message: str = "") -> None:
        try:
            if not template_id:
                payload = {const.TILE_ID: message}
            else:
                payload = {const.TEMPLATE_ID: template_id, const.TILE_ID: message}
            self.client.requests[request_id](const.APPROVE_ACTION).post(
                payload=payload)

            self.request_data.set_status('approved')
        except ClientError as ex:  # pragma: no cover
            # Capturing Connect response "REQ_003 - Only pending and inquiring requests can
            # be approved"
            if ex.error_code == const.CONNECT_ERROR_CODE_APPROVE_NOT_PENDING_INQUIRING:
                return
            raise

        return BackgroundResponse.done()

    def fail_request(self, request_id: str, error_message: str) -> None:
        self.client.requests[request_id](const.FAIL_ACTION).post(
            payload={const.KEY_REASON: error_message})

        self.request_data.set_status('failed')
        self.request_data.set_reason(error_message)

        return BackgroundResponse.done()

    def inquire_request(self, request_id: str) -> None:
        template = self.client.products[self.request_data.product_id()].templates.filter(
            scope=const.ASSET,
            type=const.INQUIRE_ACTION,
        ).first()

        self.client.requests[request_id](const.INQUIRE_ACTION).post(
            payload={const.TEMPLATE_ID: template['id']})

        self.request_data.set_status('inquiring')

        return BackgroundResponse.done()

    def get_subscription_activation_template(self) -> str:
        return self.request_data.subscription_activation_template_id()

    def get_msp_account_id_fulfillment(self) -> str:
        return self.request_data.msp_account_id_fulfillment()

    def get_license_key(self) -> str:
        return self.request_data.license_key()

    def get_user_id(self) -> str:
        return self.request_data.user_id()

    def get_allocations(self) -> str:
        return self.request_data.allocations()

    def get_site_id(self) -> str:
        return self.request_data.site_id()

    def update_parameters(self, request_id: str, params: dict) -> dict:
        return self.client.requests[request_id].update(payload=params)

    def api_client(self) -> APIClient:

        return APIClient(
            mb_oauth_url=self.request_data.api_url(),
            mb_oauth_client_id=self.request_data.api_client_id(),
            mb_oauth_client_secret=self.request_data.api_secret(),
            mb_api_url=self.request_data.api_url(),
            logger=self.logger)

    def api_client_oneview(self, client_id, client_secret) -> APIClientOneView:

        return APIClientOneView(
            mb_oauth_url=self.request_data.oneview_api_url(),
            mb_oauth_client_id=client_id,
            mb_oauth_client_secret=client_secret,
            mb_api_url=self.request_data.oneview_api_url(),
            logger=self.logger)

    def account_repository(self) -> AccountRepository:
        return MBAccountRepository(self.api_client(), self.logger)

    def oneview_repository(self, client_id, client_secret) -> OneViewRepository:
        return OneviewRepository(self.api_client_oneview(client_id, client_secret), self.logger)

    def get_asset(self, asset_id: str) -> dict:
        return self.client.assets[asset_id].get()

    def validate_items(self) -> Optional:
        """
        Checks if product items are correctly configured
        For 'Rating Plan - Reservation' only one must be added.
        """
        self.logger.info('Checking item values.')

        if not self.request_data.rating_plan_item():
            self.logger.error(f'There is no Rating Plan item in request {self.request_data.id()}.')
            raise RatingPlanError(RATING_PLAN_PARAMETER_NOT_FOUND)

        cont = 0
        reservation_item = ""
        all_items = self.request_data.rating_plan_items()
        for item in all_items:
            if item.get('item_type') == const.RESERVATION_ITEM:
                cont += 1
                reservation_item = item

        # Check if there is only one reservation item.
        if cont <= 1 and reservation_item != "":
            params_item = reservation_item.get('params')
            for param in params_item:
                if param.get('id') == const.BILLING_TYPE:
                    return
            raise OrderingError(ITEM_TYPE_NOT_VALID)

        # If there are more than one Item type Reservation show an error.
        if cont > 1:
            self.logger.error(f'There are more than one Rating Plan item in request '
                              f'{self.request_data.id()}.')

        raise OrderingError(RATING_PLAN_PARAMETER_NOT_VALID)

    def check_if_new_subscription(
            self,
            error_params) -> Union[Tuple[bool, MSPAccount, Any], Tuple[bool, MSPAccount, Dict]]:
        """
        Know if customer want to create a new one subscription or import an existing one.
        :param error_params:
        :return:
        """

        existing_email_connect = ProcessingFlow.find_email_in_assets(self)
        existing_account = ProcessingFlow.check_existing_email(self)

        # This email is using in Connect and MalwareBytes. You cannot use this email.
        if existing_email_connect and existing_account:
            self.logger.error(f"Email {self.email} already exists in Connect and MalwareBytes.")
            error_params.append({
                "id": const.CONTACT_EMAIL_NAME,
                "value_error": EXISTING_EMAIL.format(self.email)})
            return False, existing_account, error_params

        # This email is using in Connect, but not in MalwareBytes. It is a conflict.
        if existing_email_connect and not existing_account:
            self.logger.error(
                f"Email {self.email} already exists in Connect, but not in MalwareBytes. "
                f"Please contact the administrator")
            error_params.append({
                "id": const.CONTACT_EMAIL_NAME,
                "value_error": MISMATCH_EMAIL.format(self.email)})
            return False, existing_account, error_params

        # This email not exists in Connect but exists in MalwareBytes. Import Account.
        if not existing_email_connect and existing_account:
            # We check if is a previous failed provisioning.
            # It will continue with creation subscription in the last step.
            if self.get_msp_account_id_fulfillment():
                self.logger.info(f"Creation of account with Email {self.email} failed in previous "
                                 f"steps. Purchase will continue in the last step.")
                return False, existing_account, error_params

            self.logger.info("Customer is trying to import an account of MalwareBytes.")
            error_params = ProcessingFlow.validate_import_subscription(
                self, error_params, existing_account)
            return False, existing_account, error_params

        # In this case we are going to create a new Account.
        return True, existing_account, error_params

    def validate_import_subscription(self, error_params,
                                     existing_account: MSPAccount) -> dict:
        """
        Check MSP account ID to subscription type import.
        :param existing_account:
        :param error_params:
        :return: dict
        """

        if self.request_data.billing_type() == const.TRIAL:
            self.logger.error(
                f"There is a MalwareBytes Account to email {self.email}. You cannot create a "
                f"Trial Subscription for it.")
            error_params.append({
                "id": const.MSP_ACCOUNT_ID,
                "value_error": INVALID_MSP_ID_FORMAT_MESSAGE.format(
                    self.request_data.msp_account_id())})
        else:
            if self.request_data.msp_account_id_fulfillment():
                account_id = self.request_data.msp_account_id_fulfillment()
            else:
                account_id = self.request_data.msp_account_id()

            try:
                msp_account_id = AccountId(account_id).value

                if existing_account['msp_account_id'] != msp_account_id:
                    self.logger.error("MSP Account ID does not exists in MalwareBytes.")
                    error_params.append({
                        "id": const.MSP_ACCOUNT_ID,
                        "value_error": NOT_EXISTING_MSP_ACCOUNT_ID.format(msp_account_id)})

            except InvalidMspIdFormatError:
                self.logger.error("Invalid format for MSP Account ID.")
                error_params.append({
                    "id": const.MSP_ACCOUNT_ID,
                    "value_error": INVALID_MSP_ID_FORMAT_MESSAGE.format(account_id)})

        return error_params


class ProcessingFlow(Flow):
    @property
    def product_id(self):
        return self.config[const.PRODUCT_ID]

    """
    A subclass for standard business flows (Purchase, Change, Cancel, Suspend, Resume, Tier Config)
    """

    def handle(self) -> BackgroundResponse:  # pragma: no cover
        try:
            result = super().handle()

        except ConfigurationError as ex:
            result = BackgroundResponse.fail(str(ex))

        return result

    def check_existing_email(self) -> MSPAccount:
        """
        Checks if Email already exists in MalwareBytes.
        :return:
        """
        self.logger.info(f"Validating if Email {self.email.value} is using in MalwareBytes.")
        existing_account = AccountGetter(self.account_repository()).execute(Email(self.email.value))

        return existing_account

    def find_email_in_assets(self) -> bool:
        # Gets the Assets for the given Contract
        assets = AssetsGetter(self.client, self.logger).execute(
            product_id=self.request_data.product_id())

        self.logger.info(f"Validating if Email {self.email.value} is using in Connect.")

        for asset in assets:
            params = asset.get('params')
            for param in params:
                if param.get('id') == 'contact_email_name':
                    if param.get('value') == self.email.value:
                        self.logger.info("Email Address find in Connect.")
                        return True

        return False


class ValidationFlow(Flow):
    """A subclass for validation flows"""

    def handle(self) -> InteractiveResponse:  # pragma: no cover
        try:
            return super().handle()
        except ConfigurationError:
            if self.request_data.status() == const.STATUS_DRAFT:
                return InteractiveResponse.done(body=self.request_data.request)
            return InteractiveResponse.fail()


class ActionFlow(Flow):
    """A subclass for product actions"""

    def __init__(self, request, client, logger, config):
        super().__init__(request, client, logger, config)
        self.request_data = request

    def handle(self) -> InteractiveResponse:  # pragma: no cover
        try:
            return super().handle()
        except ConfigurationError:
            return InteractiveResponse.done(body='Error')


class WithStepExecutor(object):
    """A mixin for executing multiple steps"""

    def execute_all(self, functions: List[callable]) -> Optional[Union[
        BackgroundResponse, InteractiveResponse,
    ]]:
        for function in functions:
            result = function(self)

            if isinstance(result, (BackgroundResponse, InteractiveResponse)):
                return result

        if isinstance(self, ValidationFlow):
            return InteractiveResponse.done(body=self.request_data.request)

        return BackgroundResponse.done()
