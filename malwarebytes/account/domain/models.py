import json
import re

import pycountry

from typing import Optional
from dataclasses import dataclass
from datetime import date, datetime, timedelta

from malwarebytes.account.domain.exceptions import (
    InvalidCityNameFormatError, InvalidCompanyNameFormatError, InvalidCountryNameFormatError,
    InvalidEmailFormatError, InvalidFirstNameFormatError, InvalidIpFormatError,
    InvalidLastNameFormatError, InvalidMspIdFormatError, InvalidPhoneFormatError,
    InvalidStateNameFormatError, InvalidStreetNameFormatError,
)
from malwarebytes.account.domain.messages import (
    CITY_NAME_INVALID_FORMAT_MESSAGE, COMPANY_NAME_INVALID_FORMAT_MESSAGE,
    COUNTRY_NAME_INVALID_FORMAT_MESSAGE, EMAIL_INVALID_FORMAT_MESSAGE,
    FIRST_NAME_INVALID_FORMAT_MESSAGE, INVALID_MSP_ID_FORMAT_MESSAGE, IP_INVALID_FORMAT_MESSAGE,
    LAST_NAME_INVALID_FORMAT_MESSAGE, PHONE_INVALID_FORMAT_MESSAGE,
    STATE_NAME_INVALID_FORMAT_MESSAGE, STREET_INVALID_FORMAT_MESSAGE,

)

PARAM_MIN_LENGTH = 2
MAX_LENGTH_NAME = 40
MAX_LENGTH_LAST_NAME = 80
EMAIL_REGULAR_EXPRESSION = r'([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\.[A-Z|a-z]{2,})+'
IP_REGULAR_EXPRESSION = r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'
MSP_ID_REGULAR_EXPRESSION = r'[A-Fa-f0-9]{64}'
PHONE_REGULAR_EXPRESSION = ("^\\+?\\d{1,4}?[-.\\s]?\\(?\\d{1,3}?\\)?[-.\\s]?\\d{1,4}[-.\\s]?\\"
                            "d{1,4}[-.\\s]?\\d{1,9}$")


@dataclass(frozen=True)
class Id:
    value: str


@dataclass(frozen=True)
class Date:
    value: str


@dataclass(frozen=True)
class MspId:
    value: str

    def __post_init__(self):
        self._value_must_have_valid_format()

    def _value_must_have_valid_format(self):
        """
        Length must be 64 characters

        Raises
        ------
        InvalidMspIdFormatError
            If the value is not valid.
        """
        if not re.match(MSP_ID_REGULAR_EXPRESSION, self.value):
            raise InvalidMspIdFormatError(INVALID_MSP_ID_FORMAT_MESSAGE.format(self.value))


@dataclass(frozen=True)
class Ip:
    value: str

    def __post_init__(self):
        self._value_must_have_valid_format()

    def _value_must_have_valid_format(self):
        """
        Length must be at least 1 character and no more than 64 characters

        Raises
        ------
        InvalidIpFormatError
            If the value is not valid.
        """
        if not re.match(IP_REGULAR_EXPRESSION, self.value):
            raise InvalidIpFormatError(IP_INVALID_FORMAT_MESSAGE.format(self.value))


@dataclass(frozen=True)
class Name:
    value: str

    def __post_init__(self):
        self._value_must_have_valid_format()

    def _value_must_have_valid_format(self):
        """
        Length must be at least 1 character and no more than 64 characters

        Raises
        ------
        InvalidNameFormatError
            If the value is not valid.
        """
        if len(self.value) < PARAM_MIN_LENGTH or len(self.value) > MAX_LENGTH_NAME:
            raise InvalidFirstNameFormatError(FIRST_NAME_INVALID_FORMAT_MESSAGE.format(self.value))

    def __eq__(self, other):
        if not isinstance(other, Name):
            return False

        return self.value == other.value


@dataclass(frozen=True)
class SurName:
    value: str

    def __post_init__(self):
        self._value_must_have_valid_format()

    def _value_must_have_valid_format(self):
        """
        Length must be at least 1 character and no more than 64 characters

        Raises
        ------
        InvalidNameFormatError
            If the value is not valid.
        """
        if len(self.value) < PARAM_MIN_LENGTH or len(self.value) > MAX_LENGTH_NAME:
            raise InvalidLastNameFormatError(LAST_NAME_INVALID_FORMAT_MESSAGE.format(self.value))

    def __eq__(self, other):
        if not isinstance(other, Name):
            return False

        return self.value == other.value


@dataclass(frozen=True)
class Email:
    value: str

    def __post_init__(self):
        self._value_must_have_valid_format()

    def _value_must_have_valid_format(self):
        """
        Length must be at least 1 character and no more than 64 characters

        Raises
        ------
        InvalidEmailFormatError
            If the value is not valid.
        """
        if len(self.value) < PARAM_MIN_LENGTH or len(self.value) > MAX_LENGTH_NAME:
            raise InvalidEmailFormatError(EMAIL_INVALID_FORMAT_MESSAGE.format(self.value))

        if not re.match(EMAIL_REGULAR_EXPRESSION, self.value):
            raise InvalidEmailFormatError(EMAIL_INVALID_FORMAT_MESSAGE.format(self.value))

    def __eq__(self, other):
        if not isinstance(other, Name):
            return False

        return self.value == other.value


@dataclass(frozen=True)
class Phone:
    value: str

    def __post_init__(self):
        self._value_must_have_valid_format()

    def _value_must_have_valid_format(self):
        """
        Length must be at least 1 character and no more than 64 characters

        Raises
        ------
        InvalidNameFormatError
            If the value is not valid.
        """
        if not re.match(PHONE_REGULAR_EXPRESSION, self.value):
            raise InvalidPhoneFormatError(PHONE_INVALID_FORMAT_MESSAGE.format(self.value))

    def __eq__(self, other):
        if not isinstance(other, Name):
            return False

        return self.value == other.value


@dataclass(frozen=True)
class ContactCompanyName:
    value: str

    def __post_init__(self):
        self._value_must_have_valid_format()

    def _value_must_have_valid_format(self):
        """
        Length must be at least 1 character and no more than 64 characters

        Raises
        ------
        InvalidNameFormatError
            If the value is not valid.
        """
        if len(self.value) < PARAM_MIN_LENGTH or len(self.value) > MAX_LENGTH_NAME:
            raise InvalidCompanyNameFormatError(
                COMPANY_NAME_INVALID_FORMAT_MESSAGE.format(self.value))

    def __eq__(self, other):
        if not isinstance(other, Name):
            return False

        return self.value == other.value


@dataclass(frozen=True)
class BillingStreet:
    value: str

    def __post_init__(self):
        self._value_must_have_valid_format()

    def _value_must_have_valid_format(self):
        """
        Length must be at least 1 character and no more than 64 characters

        Raises
        ------
        InvalidNameFormatError
            If the value is not valid.
        """
        if len(self.value) < PARAM_MIN_LENGTH or len(self.value) > MAX_LENGTH_NAME:
            raise InvalidStreetNameFormatError(STREET_INVALID_FORMAT_MESSAGE.format(self.value))

    def __eq__(self, other):
        if not isinstance(other, Name):
            return False

        return self.value == other.value


@dataclass(frozen=True)
class BillingCity:
    value: str

    def __post_init__(self):
        self._value_must_have_valid_format()

    def _value_must_have_valid_format(self):
        """
        Length must be at least 1 character and no more than 64 characters

        Raises
        ------
        InvalidNameFormatError
            If the value is not valid.
        """
        if len(self.value) < PARAM_MIN_LENGTH or len(self.value) > MAX_LENGTH_NAME:
            raise InvalidCityNameFormatError(CITY_NAME_INVALID_FORMAT_MESSAGE.format(self.value))

    def __eq__(self, other):
        if not isinstance(other, Name):
            return False

        return self.value == other.value


@dataclass(frozen=True)
class BillingCountry:
    value: str

    def __post_init__(self):
        self._value_must_have_valid_format()

    def _value_must_have_valid_format(self):
        """
        Length must be at least 1 character and no more than 64 characters

        Raises
        ------
        InvalidNameFormatError
            If the value is not valid.
        """
        if len(self.value) < PARAM_MIN_LENGTH or len(self.value) > MAX_LENGTH_NAME:
            raise InvalidCountryNameFormatError(
                COUNTRY_NAME_INVALID_FORMAT_MESSAGE.format(self.value))

        if pycountry.countries.get(alpha_2=self.value) is None:
            raise InvalidCountryNameFormatError(
                COUNTRY_NAME_INVALID_FORMAT_MESSAGE.format(self.value))

    def __eq__(self, other):
        if not isinstance(other, Name):
            return False

        return self.value == other.value


@dataclass(frozen=True)
class BillingState:
    value: str

    def __post_init__(self):
        self._value_must_have_valid_format()

    def _value_must_have_valid_format(self):
        """
        Length must be at least 1 character and no more than 64 characters

        Raises
        ------
        InvalidNameFormatError
            If the value is not valid.
        """
        if len(self.value) < PARAM_MIN_LENGTH or len(self.value) > MAX_LENGTH_NAME:
            raise InvalidStateNameFormatError(STATE_NAME_INVALID_FORMAT_MESSAGE.format(self.value))

    def __eq__(self, other):
        if not isinstance(other, Name):
            return False

        return self.value == other.value


@dataclass
class Numeric:
    value: int

    def __eq__(self, other):
        if not isinstance(other, Numeric):
            return False

        return self.value == other.value

    def __lt__(self, other):
        return self.value < other.value

    def __gt__(self, other):
        return self.value > other.value


@dataclass
class BillingType:
    value: str


@dataclass
class ProductUsage:
    catalog_code: str
    billable_catalog_code: str
    combo_code: str
    billable_combo_code: str
    license_term_type: str
    billable_term_type: str
    usage: str


class AccountId(MspId):
    pass


@dataclass
class AccountBilling:
    item_id: BillingType
    product_line: ProductUsage


@dataclass
class Time:
    value: date


class FirstName(Name):
    pass


class LastName(SurName):
    pass


class CompanyName(ContactCompanyName):
    pass


class Street(BillingStreet):
    pass


class City(BillingCity):
    pass


class Country(BillingCountry):
    pass


class State(BillingState):
    pass


class Account:
    def __init__(self, company_name: CompanyName, street: Street, city: City,
                 country: Country, state: State, term_type: str, test_account: bool) -> None:
        self._company_name = company_name
        self._street = street
        self._city = city
        self._country = country
        self._state = state
        self._term_type = term_type
        self._test_account = test_account

    @property
    def company_name(self):
        return self._company_name

    @property
    def state(self):
        return self._state

    @property
    def street(self):
        return self._street

    @property
    def city(self):
        return self._city

    @property
    def country(self):
        return self._country

    @property
    def term_type(self):
        return self._term_type


class Contact:
    def __init__(self, first_name: FirstName, last_name: LastName, email: Email,
                 phone: Phone) -> None:
        self._first_name = first_name
        self._last_name = last_name
        self._email = email
        self._phone = phone

    @property
    def email(self):
        return self._email

    @property
    def first_name(self):
        return self._first_name

    @property
    def last_name(self):
        return self._last_name

    @property
    def phone(self):
        return self._phone


class AccountToInject:
    def __init__(self, account: json) -> None:
        self._account = account


class LicenseType(Name):
    pass


class Status(Name):
    pass


class License(Id):
    pass


class MSPAccount:
    def __init__(self, msp_account_id: MspId, msp_company_name: CompanyName,
                 license_type: LicenseType, account_status: Status,
                 test_account: bool, user_count: int, site_count: int,
                 nebula_account_id: MspId, license_key: License) -> None:
        self._msp_account_id = msp_account_id
        self._msp_company_name = msp_company_name
        self._license_type = license_type
        self._account_status = account_status
        self._test_account = test_account
        self._user_count = user_count
        self._users = MSPUser
        self._site_count = site_count
        self._sites = MSPSites
        self._nebula_account_id = nebula_account_id
        self._owner = Owner
        self._license_key = license_key


class AccountCreated:
    def __init__(self, account_id: MspId, vendor_id: MspId) -> None:
        self._account_id = account_id
        self._vendor_id = vendor_id


class LoginIP(Ip):
    pass


class LoginDate(Date):
    pass


class MSPUser:
    def __init__(self, user_id: MspId, user_email: Email, user_firstname: FirstName,
                 user_lastname: LastName, user_status: Status, user_last_login_ip: LoginIP,
                 user_last_login_date: LoginDate) -> None:
        self._user_id = user_id
        self._user_email = user_email
        self._user_firstname = user_firstname
        self._user_lastname = user_lastname
        self._user_status = user_status
        self._user_last_login_ip = user_last_login_ip
        self._user_last_login_date = user_last_login_date


class MSPSites:
    def __init__(self, site_id: MspId, nebula_id: MspId, firstname: FirstName,
                 lastname: LastName, site_name: CompanyName, status: Status) -> None:
        self._site_id = site_id
        self._nebula_id = nebula_id
        self._firstname = firstname
        self._lastname = lastname
        self._site_name = site_name
        self._status = status


class Owner:
    def __init__(self, email: Email, display_name: CompanyName) -> None:
        self._email = email
        self._display_name = display_name


class Period:

    def __init__(self, start: Time, end: Time = None) -> None:
        self.start = start
        self.end = end if end else start

    @staticmethod
    def last_day():
        return Period(Time(datetime.now() - timedelta(days=1)), Time(datetime.now()))


class BillingCriteria:

    def __init__(self, usage_period: Optional[Period] = None,
                 billing_period: Optional[Time] = None) -> None:
        self.usage_period = usage_period
        self.billing_period = billing_period
