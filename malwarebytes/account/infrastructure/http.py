from __future__ import annotations

import json
import base64
from abc import ABC
from typing import Any, Optional, Tuple
from datetime import date

import requests
from requests import Response
from malwarebytes.account.domain.contracts import AccountRepository, OneViewRepository
from malwarebytes.account.infrastructure.exceptions import (
    AccountDataNotValidException, AccountExistingEmailException, AuthenticationException,
    ConnectionTimeoutException, ConnectionUnauthorizedException, LimitExceeded,
    MalwareBytesException, MalwareBytesServerException, MBClientException, SiteNotValidException,
    TrialSubscriptionNotValidException,
)
from malwarebytes.account.domain.models import (
    Account, AccountBilling, AccountCreated, AccountId, AccountToInject, Email, MSPAccount,
)
from malwarebytes.account.application.contracts import Logger
from malwarebytes.account.infrastructure.logger import (
    formatter_api_request,
    formatter_api_response,
)

VALID_RESPONSE = 200
ACCOUNT_DATA_NOT_VALID = 400
ACCOUNT_DATA_ALREADY_EXIST = 409
CONNECTION_UNAUTHORIZED = 401
DATA_NOT_VALID = 500

ACCOUNT_CREDENTIALS = 'account_credentials'
HEADERS_TYPE = 'application/json'

NUMBER_ACCOUNT_PER_PAGE = 200


class APIClient:
    """
    API Client to performs the API calls
    """

    def __init__(
            self,
            mb_oauth_url: str,
            mb_oauth_client_id: str,
            mb_oauth_client_secret: str,
            mb_api_url: str,
            logger: Logger,
            max_retries: int = 3,
    ):
        """
       Parameters
       ----------
       mb_oauth_url: str
           OAUTH URL.
       mb_oauth_client_id: str
           Client ID.
       mb_oauth_client_secret: str
           Client Secret.
       mb_api_url: str
           API URL used for send the requests
       logger: Logger

       """
        self.logger = logger
        self.mb_oauth_url = mb_oauth_url
        self.mb_oauth_client_id = mb_oauth_client_id
        self.mb_oauth_client_secret = mb_oauth_client_secret
        self.host = mb_api_url
        self.max_retries = max_retries

    def send(
            self,
            method: str,
            path: str,
            query: Optional[dict] = None,
            body: Optional[dict] = None,
    ) -> Response:
        """
        Sends a requests to MalwareBytes API.

        Parameters
        ----------
        method: str
            The HTTP method to use.

        path: str, None
            The path to the resource.

        query: dict, optional
            The parameters of the requests to be sent.

        body: dict, optional
            The body of the requests to be sent.

        Returns
        -------
        response: Response
            The response
        """

        retries = 0
        success = False

        while retries < self.max_retries and not success:
            retries += 1
            try:
                token = self.get_token()
                headers = {
                    'Authorization': f"Bearer {token}",
                    'Content-Type': HEADERS_TYPE,
                    'Accept': HEADERS_TYPE,
                }
                self.logger.info(formatter_api_request(method, self.get_url(path), headers, body))

                try:
                    response = requests.request(
                        method,
                        self.get_url(path),
                        headers=headers,
                        params=query,
                        json=body,
                        verify=True,
                        timeout=(180, 540),
                    )
                except ConnectionError as e:
                    raise ConnectionTimeoutException(str(e))

                self.logger.debug(formatter_api_response(response))

                if response.status_code >= 500:
                    raise _make_server_error(response)

                if response.status_code >= 400:
                    raise _make_client_error(response)

                success = True
                return response.content
            except AuthenticationException as e:
                self.logger.warning("{error} with message {msg} retrying {retries}/{max}".format(
                    error=e.__class__.__name__,
                    msg=e,
                    retries=retries,
                    max=self.max_retries,
                ))

                if retries == self.max_retries:
                    raise

    def get_url(self, action_path: str):
        """
        Creates the URL to the resource for the requests.

        Parameters
        ----------
        action_path: str
            The path to the resource. It should start with a slash.
        """
        return f'{self.host}{action_path}'

    def get_token(self):
        """
        Get Token.
        """

        base64_str = base64.b64encode(
            bytes(self.mb_oauth_client_id + ':' + self.mb_oauth_client_secret, 'utf-8'),
        )
        base64_authorization = base64_str.decode('utf-8')

        token_url = self.mb_oauth_url + '/oauth2/token'
        payload = 'scope=oneview-partner&grant_type=client_credentials'
        headers = {'Content-Type': 'application/x-www-form-urlencoded',
                   'Authorization': 'Basic ' + base64_authorization}

        response = requests.post(token_url, headers=headers, data=payload)

        if response.status_code == 200:
            token_data = json.loads(response.content)
            access_token = token_data["access_token"]
            self.logger.debug(formatter_api_response(response))
        else:
            self.logger.error(f"There was an error try to get Access Token. Error Code: "
                              f"{response.status_code}")
            raise AuthenticationException(
                f"There was an error try to get Access Token. Error Code: {response.status_code} "
                f"Message: {response.reason}")

        return access_token


class APIClientOneView:
    """
    API Client of OneView
    """

    def __init__(
            self,
            mb_oauth_url: str,
            mb_oauth_client_id: str,
            mb_oauth_client_secret: str,
            mb_api_url: str,
            logger: Logger,
            max_retries: int = 3,
    ):
        """
       Parameters
       ----------
       mb_oauth_url: str
           OAUTH URL.
       mb_oauth_client_id: str
           Client ID.
       mb_oauth_client_secret: str
           Client Secret.
       mb_api_url: str
           API URL used for send the requests
       logger: Logger

       """
        self.logger = logger
        self.mb_oauth_url = mb_oauth_url
        self.mb_oauth_client_id = mb_oauth_client_id
        self.mb_oauth_client_secret = mb_oauth_client_secret
        self.host = mb_api_url
        self.max_retries = max_retries

    def send(
            self,
            method: str,
            path: str,
            query: Optional[dict] = None,
            body: Optional[dict] = None,
    ) -> Response:
        """
        Sends a requests to MalwareBytes Oneview API.

        Parameters
        ----------
        method: str
            The HTTP method to use.

        path: str, None
            The path to the resource.

        query: dict, optional
            The parameters of the requests to be sent.

        body: dict, optional
            The body of the requests to be sent.

        Returns
        -------
        response: Response
            The response
        """

        retries = 0
        success = False

        while retries < self.max_retries and not success:
            retries += 1
            try:
                token = self.get_token()
                headers = {
                    'Authorization': f"Bearer {token}",
                    'Content-Type': HEADERS_TYPE,
                    'Accept': HEADERS_TYPE,
                }
                self.logger.info(formatter_api_request(method, self.get_url(path), headers, body))

                try:
                    response = requests.request(
                        method,
                        self.get_url(path),
                        headers=headers,
                        params=query,
                        json=body,
                        verify=True,
                        timeout=(180, 540),
                    )
                except ConnectionError as e:
                    raise ConnectionTimeoutException(str(e))

                self.logger.debug(formatter_api_response(response))

                if response.status_code >= 500:
                    raise _make_server_error(response)

                if response.status_code >= 400:
                    raise _make_client_error(response)

                success = True
                return response.content
            except AuthenticationException as e:
                self.logger.warning("{error} with message {msg} retrying {retries}/{max}".format(
                    error=e.__class__.__name__,
                    msg=e,
                    retries=retries,
                    max=self.max_retries,
                ))

                if retries == self.max_retries:
                    raise

    def get_url(self, action_path: str):
        """
        Creates the URL to the resource for the requests.

        Parameters
        ----------
        action_path: str
            The path to the resource. It should start with a slash.
        """
        return f'{self.host}{action_path}'

    def get_token(self):
        """
        Get Token.
        """

        base64_str = base64.b64encode(
            bytes(self.mb_oauth_client_id + ':' + self.mb_oauth_client_secret, 'utf-8'),
        )
        base64_authorization = base64_str.decode('utf-8')

        token_url = self.mb_oauth_url + '/oauth2/token'
        payload = 'scope=read write execute&grant_type=client_credentials'
        headers = {'Content-Type': 'application/x-www-form-urlencoded',  # specific to my app
                   'Authorization': 'Basic ' + base64_authorization,
                   }

        response = requests.post(token_url, headers=headers, data=payload)

        if response.status_code == 200:
            token_data = json.loads(response.content)
            access_token = token_data["access_token"]
            self.logger.debug(formatter_api_response(response))
        else:
            self.logger.error(f"There was an error try to get Access Token. Error Code: "
                              f"{response.status_code}")
            raise AuthenticationException(
                f"There was an error try to get Access Token. Error Code: {response.status_code} "
                f"Message: {response.reason}")

        return access_token


def _make_server_error(response: Response) -> MalwareBytesException:
    """
    Makes a Server Error Exception (error >= 500)
    Parameters
    ----------
    response: Response
        Response from Zoom API
     Returns
    -------
        The MalwareBytesException.
    """
    return MalwareBytesServerException(response.text, str(response.status_code), {
        'response': response,
    })


def _make_client_error(response: Response) -> MalwareBytesException:
    """
    Makes a Client Error Exception (400 <= error < 500)
    Parameters
    ----------
    response: Response
        Response from MalwareBytes API
     ReturnsF
    -------
        The MalwareBytesException.
    """
    body = response.json()
    message = body.get("message", response.reason)
    code = str(body.get("code", str(response.status_code)))

    # Throttling limit is 360 calls per minute.
    # When the limit is reached the API server will respond with a 429 HTTP status code.
    if code in ['429']:
        return LimitExceeded(message, code)
    elif response.status_code == ACCOUNT_DATA_ALREADY_EXIST:
        return AccountExistingEmailException(message, code)
    elif response.status_code == CONNECTION_UNAUTHORIZED:
        return AuthenticationException(message, code)
    elif response.status_code == ACCOUNT_DATA_NOT_VALID:
        return AccountDataNotValidException(message, code)

    return MBClientException(message, code, {
        'response': response,
    })


class OneviewRepository(OneViewRepository, ABC):
    def __init__(self, api_client_oneview: APIClientOneView, logger=None) -> None:
        self.api_client_oneview = api_client_oneview
        self.logger = logger

    def create_site(self, body) -> str | None:
        """
        Create Site for MSP Account ID
        :param body:
        :return: str
        """

        new_site = self.api_client_oneview.send("POST", "/oneview/v1/sites", body=body)

        new_site_dict = json.loads(new_site)

        if new_site_dict.get("statusCode"):
            if new_site_dict.get("statusCode") != VALID_RESPONSE:
                self.logger.error(
                    f"It was not possible to create a site due to response of API return an error: "
                    f"{new_site_dict['message']}")
                raise SiteNotValidException(new_site_dict)

        if len(new_site_dict) == 0:
            return None

        self.logger.info(
            f"New Site create for Account with ID {new_site_dict.get('id')}")

        return new_site_dict.get('id')

    def create_trial_subscription(self, site_id, body):
        """
        Create Trial Subscription for MSP Account ID
        :param site_id:
        :param body:
        """

        response_orig = self.api_client_oneview.send(
            "POST", f"/oneview/v2/sites/{site_id}/subscriptions", body=body)

        response = json.loads(response_orig)[0]

        if response.get("statusCode"):
            if response.get("statusCode") != VALID_RESPONSE:
                self.logger.error(
                    f"It was not possible to create a trial subscription due to response of API "
                    f"return an error: {response['message']}")
                raise TrialSubscriptionNotValidException(response)

        self.logger.info(f"New Trial Subscription created to site Id {site_id}")


class MBAccountRepository(AccountRepository, ABC):
    def __init__(self, api_client: APIClient, logger=None) -> None:
        self.api_client = api_client
        self.logger = logger

    def find(self, email: Email) -> Optional[MSPAccount]:
        """
        Search Email in Accounts MalwareBytes.
        :param email:
        :return: Optional[MSPAccount]
        """

        page_number = 0
        while True:
            # Gets all accounts in MalwareBytes. Api not let us get account by Email.
            accounts_list = self.api_client.send(
                "GET", f"/api/v2/partners/oneview/accounts?page={page_number}&"
                       f"perPage={NUMBER_ACCOUNT_PER_PAGE}")

            accounts_dict = json.loads(accounts_list)
            msp_accounts = accounts_dict['msp_accounts']
            page_number += 1

            for msp_account in msp_accounts:
                if email.value == msp_account.get('owner').get('email'):
                    self.logger.info(f"Account with Email {email.value} found.")
                    return msp_account

            if accounts_dict['total_count'] <= NUMBER_ACCOUNT_PER_PAGE or len(msp_accounts) < 1:
                break

        self.logger.info(f"Account with Email {email.value} does not exist")
        return None

    def update(self, account: AccountToInject) -> AccountToInject | AccountCreated:
        """
        Return existing account or create a new Account in MalwareBytes.
        :param account:
        :return: MSPAccount
        """
        email = Email(account["contact"]["contact_email"])

        mb_account = self.find(email)
        if mb_account:
            return account

        new_account = self._create_account(account)
        return new_account

    def get_credentials(
            self, msp_account_id: AccountId, msp_user_id: AccountId) -> Tuple[Any, Any] | None:
        """
        Get Credentials for MSP Account ID
        :param msp_account_id:
        :param msp_user_id:
        :return: Tuple[str, str]
        """

        body = {
            "client_name": "sit magna",
            "access": [
                "read",
                "write",
                "execute",
            ],
        }

        credentials = self.api_client.send(
            "POST", f"/api/v2/partners/oneview/credentials/{msp_account_id}/{msp_user_id}",
            body=body)

        credentials_dict = json.loads(credentials)

        if len(credentials_dict) == 0:
            return None

        self.logger.info(f"Get Credentials for Account with ID {credentials_dict}")
        return credentials_dict.get('client_id'), credentials_dict.get('client_secret')

    def _create_account(self, account: Account) -> AccountCreated:
        """
        Creates a new Account in MalwareBytes

        Parameters
        ----------
        account: Account
            The Account to create in MalwareBytes

        return: MSPAccount
            The Account created in MalwareBytes
        """

        response = self.api_client.send("POST", "/api/v2/partners/oneview/accounts", body=account)

        '''
        statusCode= 400; error= Bad Request
        statusCode= 401; error= Unauthorized
        statusCode= 409; error= Conflict; message= "Email already in use in Malwarebytes"
        '''
        response = json.loads(response)

        if response.get("statusCode"):
            if response.get("statusCode") == ACCOUNT_DATA_NOT_VALID:
                self.logger.error(
                    f"It was not possible to create the Account {response['message']}")
                raise AccountDataNotValidException(response)
            elif response.get("statusCode") == ACCOUNT_DATA_ALREADY_EXIST:
                self.logger.error(
                    f'Account with Email {account["contact"]["contact_email"]} already '
                    f'exists')
                raise AccountExistingEmailException(response['message'])
            elif response["statusCode"] == CONNECTION_UNAUTHORIZED:
                self.logger.error(
                    'It was not possible to connect API MalwareBytes, please review your '
                    'credentials.')
                raise ConnectionUnauthorizedException(response['message'])

        return response

    def find_msp_account_id(self, msp_account_id: AccountId) -> Optional[MSPAccount]:
        """
        Search if exist MSP Account ID in MalwareBytes
        :param msp_account_id:
        :return: Optional[MSPAccount]
        """

        # Get account with this msp_account_id
        account = self.api_client.send(
            "GET", f"/api/v2/partners/oneview/accounts?msp_ids={msp_account_id}")

        accounts_dict = json.loads(account)
        msp_account = accounts_dict['msp_accounts']

        if not msp_account:
            return None

        self.logger.info("MSP Account ID found.")
        return msp_account[0]

    def change(self, msp_account_id: AccountId) -> bool:
        """
        Changed MSP Account ID in MalwareBytes
        :param msp_account_id:
        :return: bool
        """

        try:
            # Change account with this msp_account_id
            self.api_client.send(
                "PUT", f"/api/v2/partners/oneview/accounts/{msp_account_id.value}/convert",
                body={})
        except MBClientException as ex:
            self.logger.error(f"Changed suspend due to: {ex.message}")
            raise

        self.logger.info(f"Account with MSP Account ID {msp_account_id.value} was Changed.")
        return True

    def cancel(self, msp_account_id: AccountId) -> bool:
        """
        Cancel MSP Account ID in MalwareBytes
        :param msp_account_id:
        :return: bool
        """

        try:
            # Cancel account with this msp_account_id
            self.api_client.send(
                "PUT", f"/api/v2/partners/oneview/accounts/{msp_account_id.value}/terminate",
                body={})
        except MBClientException as ex:
            self.logger.error(f"Failed cancellation due to: {ex.message}")
            raise

        self.logger.info(f"Account with MSP Account ID {msp_account_id.value} was cancelled.")
        return True

    def suspend(self, msp_account_id: AccountId) -> bool:
        """
        Suspend MSP Account ID in MalwareBytes
        :param msp_account_id:
        :return: bool
        """

        try:
            # Suspend account with this msp_account_id
            self.api_client.send(
                "PUT", f"/api/v2/partners/oneview/accounts/{msp_account_id.value}/suspend",
                body={})
        except MBClientException as ex:
            self.logger.error(f"Failed suspend due to: {ex.message}")
            raise

        self.logger.info(f"Account with MSP Account ID {msp_account_id.value} was Suspended.")
        return True

    def resume(self, msp_account_id: AccountId) -> bool:
        """
        Resume MSP Account ID in MalwareBytes
        :param msp_account_id:
        :return: bool
        """

        try:
            # Resume account with this msp_account_id
            self.api_client.send(
                "PUT", f"/api/v2/partners/oneview/accounts/{msp_account_id.value}/reactivate",
                body={})
        except MBClientException as ex:
            self.logger.error(f"Failed reactivation due to: {ex.message}")
            raise

        self.logger.info(f"Account with MSP Account ID {msp_account_id.value} was Reactivated.")
        return True

    def send_email(self, msp_account_id: AccountId) -> bool:
        """
        Send Invite Email.
        :param msp_account_id:
        :return: bool
        """

        try:
            # Send invite Email account with this msp_account_id
            self.api_client.send(
                "PUT", f"/api/v2/partners/oneview/accounts/{msp_account_id.value}/resend",
                body={})
        except MBClientException as ex:
            self.logger.error(f"Failed send invite email due to: {ex.message}")
            raise

        self.logger.info(f"Email sent to MSP Account ID {msp_account_id.value}.")
        return True

    def get_usage(
            self, msp_account_id: AccountId, star_date: date, end_date: date) -> AccountBilling:
        """
        Get usage per Account
        :param msp_account_id:
        :param star_date:
        :param end_date:
        :return:
        """
        try:
            body = {
                "start_date": star_date.strftime('%Y-%m-%d'),
                "end_date": end_date.strftime('%Y-%m-%d'),
                "msp_ids": [
                    msp_account_id,
                ],
            }

            # Get usage of items to this msp_account_id
            usages = self.api_client.send(
                "POST", "/api/v2/partners/oneview/usage/logs/summary",
                body=body)

            usages_dict = json.loads(usages)

            usage = self._manage_usage(usages_dict)

        except MBClientException as ex:
            self.logger.error(f"Failed get usage due to: {ex.message}")
            raise

        self.logger.info(f"Usage got to MSP Account ID {msp_account_id}.")

        return usage

    def _manage_usage(self, usages):

        items = {}
        for usage in usages:
            line_usage = usages.get(usage)
            for product_id, line_product in line_usage.items():
                if items.get(product_id):
                    item = items[product_id]
                    item['usage'] = item.get('usage') + line_product.get('usage')
                else:
                    items[product_id] = line_product

        return items
