from __future__ import annotations

from typing import Optional, Tuple, Union

import requests
from requests import Response

from rauth import OAuth2Service

from malwarebytes.account.domain.exceptions import LimitExceeded
from malwarebytes.shared.application.contracts import Authenticator, Logger
from malwarebytes.account.domain.exceptions import (
    AuthenticationException,
    MBClientException,
    ConnectionTimeoutException,
    MalwareBytesException,
    MalwareBytesServerException,
)
from malwarebytes.shared.domain.messages import TOKEN_INVALID_IS_NOT_GENERATED
from malwarebytes.shared.infrastructure.logger import (
    formatter_api_request,
    formatter_api_response,
)

ACCOUNT_CREDENTIALS = 'account_credentials'


class APIClient:
    """
    API Client to performs the API calls
    """

    def __init__(
            self,
            oauth_client: OAuth2Client,
            zoom_api_url: str,
            logger: Logger,
            max_retries: int = 3,
    ):
        """
       Parameters
       ----------
       oauth_client: OAuth2Client
           The OAuth2 Client.
       zoom_api_url: str
           API URL used for send the request
        logger: Logger
            Logger

       """
        self.logger = logger
        self.oauth_client = oauth_client
        self.host = zoom_api_url
        self.max_retries = max_retries

    def send(
            self,
            method: str,
            path: str,
            query: Optional[dict] = None,
            body: Optional[dict] = None,
    ) -> Response:
        """
        Sends a request to MalwareBytes API.

        Parameters
        ----------
        method: str
            The HTTP method to use.

        path: str, None
            The path to the resource.

        query: dict, optional
            The parameters of the request to be sent.

        body: dict, optional
            The body of the request to be sent.

        Returns
        -------
        response: Response
            The response
        """

        retries = 0
        success = False

        while retries < self.max_retries and not success:
            retries += 1
            try:
                token = self.oauth_client.authenticate()
                headers = {
                    'Authorization': f"Bearer {token}",
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                }
                self.logger.info(formatter_api_request(method, self.get_url(path), headers, body))

                try:
                    response = requests.request(
                        method,
                        self.get_url(path),
                        headers=headers,
                        params=query,
                        json=body,
                        verify=True,
                        timeout=(180, 540),
                    )
                except ConnectionError as e:
                    raise ConnectionTimeoutException(str(e))

                self.logger.info(formatter_api_response(response))

                if response.status_code >= 500:
                    raise _make_server_error(response)

                if response.status_code >= 400:
                    raise _make_client_error(response)

                success = True
                return response
            except AuthenticationException as e:
                self.logger.warning("{error} with message {msg} retrying {retries}/{max}".format(
                    error=e.__class__.__name__,
                    msg=e,
                    retries=retries,
                    max=self.max_retries,
                ))
                # Flush the token in cache so next retry fetch a new one
                self.oauth_client.flush_session()

                if retries == self.max_retries:
                    raise

    def get_url(self, action_path: str):
        """
        Creates the URL to the resource for the request.

        Parameters
        ----------
        action_path: str
            The path to the resource. It should start with a slash.
        """
        return f'{self.host}{action_path}'


class OAuth2Client(Authenticator):
    """
    Oauth2 Client to obtain the authentication token
    """

    def __init__(
            self,
            mb_oauth_url: str,
            mb_oauth_client_id: str,
            mb_oauth_client_secret: str,
            logger: Logger,
            cache: Cache,
    ):
        """
        Parameters
        ----------
        mb_oauth_url: str
            The path to the resource. It should start with a slash.
        mb_oauth_client_id: str
            Client identifier needed for token creation
        mb_oauth_client_secret: str
            Client secret needed for token creation
        logger: Logger
        """
        self.access_token = None
        self.cache = cache
        self.service = OAuth2Service(
            client_id=mb_oauth_client_id,
            client_secret=mb_oauth_client_secret,
            access_token_url=mb_oauth_url,
        )
        self.logger = logger
        self.logger.info(f'Configured OAuth2Client with {self.cache} cache.')

    def authenticate(self, grant_type: str = ACCOUNT_CREDENTIALS) -> Union[str, Tuple[str, int]]:
        """
        Get token from Oauth2.
        Parameters
        ----------
        grant_type: str
            Grant type used for oauth token creation
         Returns
        -------
            The token needed for ZOom API authentication .
        """
        self.logger.info("Getting access token")

        def __get_token() -> Union[str, Tuple[str, int]]:
            """Fetch access token"""
            try:
                response = self.service.get_raw_access_token(data={
                    'grant_type': grant_type,
                    'scope': 'oneview-partner'
                })
            except ConnectionError as e:
                raise ConnectionTimeoutException(str(e))

            self.logger.info(formatter_api_response(response))
            decoded_response = response.json()

            if response.status_code >= 500:
                raise _make_server_error(response)

            if response.status_code >= 400:
                self.logger.error("Error {e} getting access token for account_id {id}.".format(
                    e=response.status_code,
                    id=self.account_id,
                ))

                raise AuthenticationException(
                    TOKEN_INVALID_IS_NOT_GENERATED.format(
                        reason='{error}: {reason}'.format(
                            error=decoded_response.get("error"),
                            reason=decoded_response.get("reason"),
                        ),
                    ), '0')
            # The expiration time will be the given expires in - 15 minutes in seconds.
            expires_in = int(decoded_response.get('expires_in', 3599)) - 900
            access_token = decoded_response.get('access_token')
            return access_token, expires_in

        return self.cache.get(f"token-{self.account_id}", __get_token)

    def flush_session(self):
        self.cache.delete(f"token-{self.account_id}")


def _make_server_error(response: Response) -> MalwareBytesException:
    """
    Makes a Server Error Exception (error >= 500)
    Parameters
    ----------
    response: Response
        Response from Zoom API
     Returns
    -------
        The MalwareBytesException.
    """
    return MalwareBytesServerException(response.text, str(response.status_code), {
        'response': response,
    })


def _make_client_error(response: Response) -> MalwareBytesException:
    """
    Makes a Client Error Exception (400 <= error < 500)
    Parameters
    ----------
    response: Response
        Response from Zoom API
     ReturnsF
    -------
        The MalwareBytesException.
    """
    body = response.json()
    message = body.get("message", response.reason)
    errors = body.get("errors", [])
    code = str(body.get("code", str(response.status_code)))

    # Throttling limit is 360 calls per minute.
    # When the limit is reached the API server will respond with a 429 HTTP status code.
    if code in ['429']:
        return LimitExceeded(message, code)
    elif response.status_code == 401:
        return AuthenticationException(message, code)

    return MBClientException(message, code, {
        'response': response,
    })
